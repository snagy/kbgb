{"version":3,"file":"pack.js","sources":["../../src/globals.js","../../src/tuning.js","../../src/coremath.js","../../src/gfx.js","../../src/boardOps.js","../../src/ui.js","../../src/base.js"],"sourcesContent":["export const globals = {\n    pickedKeys: [],\n    renderData: { keys: {}, case: {}, mats: {}, outlines: {} }\n}","export const tuning = {\n    keyDims: [18.0, 18.0],\n    switchCutout: [14.0, 14.0],\n    base1U: [19.05, 19.05],\n    bezelGap: 1.05,\n    bezelThickness: 5,\n    bezelCornerFillet: 0.5,\n    keyShape:\"square\",\n    drawCase:true\n}","\nexport function lineLineIntersection(p0, d0, p1, d1) {\n    let det = d0.x * d1.z - d1.x * d0.z;\n    if (det < BABYLON.Epsilon) // no collision\n    {\n        return null;\n    }\n\n    let prevC = p0.x * d0.x + p0.z * d0.z;\n    let nextC = p1.x * d1.x + p1.z * d1.z;\n    let intersection = new BABYLON.Vector3((d1.z * prevC - d0.z * nextC) / det, 0,\n        (d0.x * nextC - d1.x * prevC) / det);\n\n    return intersection;\n}\n\nexport function rayToSegment(x0, xL, xNorm, y0, y1) {\n    //let xL = x1.subtract(x0);\n    let yL = y1.subtract(y0);\n    //let xNorm = (new BABYLON.Vector3(xL.z, 0, -xL.x)).normalize();\n    let yNorm = (new BABYLON.Vector3(yL.z, 0, -yL.x)).normalize();\n\n    let intersection = lineLineIntersection(x0,xNorm,y0,yNorm);\n    if(intersection) {\n        let intLenSq = intersection.subtract(y0).lengthSquared();\n        if(intLenSq > BABYLON.Epsilon && intLenSq < yL.lengthSquared() - BABYLON.Epsilon) {\n            return intersection;\n        }\n    }\n    return null;\n}\n\n// only convex\nexport function isPointInPoly(p, poly) {\n    for(let i = 0; i < poly.length; i++) {\n        let point = poly[i];\n        let next = poly[(i + 1) % poly.length];\n        let nextDir = next.subtract(point).normalize();\n        let nextNorm = new BABYLON.Vector3(nextDir.z, 0, -nextDir.x);\n        let pV = p.subtract(point).normalize();\n        let d = BABYLON.Vector3.Dot(pV,nextNorm)\n        if( d > BABYLON.Epsilon) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function getRotFromNormal(norm) {\n    let t = Math.acos(norm.x);\n    if (norm.z < 0) t = 2 * Math.PI - t;\n    return t;\n}\n\nexport function getNormalFromRot(rot) {\n    return new BABYLON.Vector3(Math.cos(rot), 0, Math.sin(rot));\n}\n\nvar EPSILON     = 1.1102230246251565e-16\nvar ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON\nfunction orient(a, b, c) {\n    var l = (a.z - c.z) * (b.x - c.x)\n    var r = (a.x - c.x) * (b.z - c.z)\n    var det = l - r\n    var s\n    if(l > 0) {\n      if(r <= 0) {\n        return det\n      } else {\n        s = l + r\n      }\n    } else if(l < 0) {\n      if(r >= 0) {\n        return det\n      } else {\n        s = -(l + r)\n      }\n    } else {\n      return det\n    }\n    var tol = ERRBOUND3 * s\n    if(det >= tol || det <= -tol) {\n      return det\n    }\n    return 0\n  }\n\n// convex hull of points on the x/z plane\nexport function convexHull2d(points) {\n    var n = points.length\n\n    if (n < 3) {\n        var result = new Array(n)\n        for (var i = 0; i < n; ++i) {\n            result[i] = i\n        }\n\n        if (n === 2 &&\n            points[0].x === points[1].x &&\n            points[0].z === points[1].z) {\n            return [0]\n        }\n\n        return result\n    }\n\n    //Sort point indices along x-axis\n    var sorted = new Array(n)\n    for (var i = 0; i < n; ++i) {\n        sorted[i] = i\n    }\n    sorted.sort(function (a, b) {\n        var d = points[a].x - points[b].x\n        if (d) {\n            return d\n        }\n        return points[a].z - points[b].z\n    })\n\n    //Construct upper and lower hulls\n    var lower = [sorted[0], sorted[1]]\n    var upper = [sorted[0], sorted[1]]\n\n    for (var i = 2; i < n; ++i) {\n        var idx = sorted[i]\n        var p = points[idx]\n\n        //Insert into lower list\n        var m = lower.length\n        while (m > 1 && orient(\n                                points[lower[m - 2]],\n                                points[lower[m - 1]],\n                                p) <= 0) {\n            m -= 1\n            lower.pop()\n        }\n        lower.push(idx)\n\n        //Insert into upper list\n        m = upper.length\n        while (m > 1 && orient(\n            points[upper[m - 2]],\n            points[upper[m - 1]],\n            p) >= 0) {\n            m -= 1\n            upper.pop()\n        }\n        upper.push(idx)\n    }\n\n    //Merge lists together\n    var result = new Array(upper.length + lower.length - 2)\n    var ptr = 0\n    for (var i = 0, nl = lower.length; i < nl; ++i) {\n        result[ptr++] = lower[i]\n    }\n    for (var j = upper.length - 2; j > 0; --j) {\n        result[ptr++] = upper[j]\n    }\n\n    let pList = [];\n    for( const i of result ) {\n        pList.unshift(points[i])\n    }\n\n    //Return result\n    return pList\n}\n\n// offset is + to the left, - to right (right won't work right now)\nexport function genArrayFromOutline(outline, offset, fillets, close, segments) {\n    let outPoints = [];\n    //todo turn fillets into array if it's just a value\n    if (!segments) {\n        segments = 4;\n    }\n\n    for (let i = 0; i < outline.length; i++) {\n        let point = outline[i];\n        let next = outline[(i + 1) % outline.length];\n        let prev = outline[(i - 1 + outline.length) % outline.length];\n        let nextDir = next.subtract(point).normalize();\n        let prevDir = point.subtract(prev).normalize();\n        let nextNorm = new BABYLON.Vector3(nextDir.z, 0, -nextDir.x);\n        let prevNorm = new BABYLON.Vector3(prevDir.z, 0, -prevDir.x);\n        let inPoint = point.add(prevNorm.scale(offset));\n        let outPoint = point.add(nextNorm.scale(offset));\n\n        let intersection = lineLineIntersection(inPoint, prevNorm,\n            outPoint, nextNorm);\n        if (intersection === null) {\n            outPoints.push(inPoint);\n            outPoints.push(outPoint);\n            continue;\n        }\n\n        if (!fillets) {\n            outPoints.push(intersection);\n        }\n        else {\n            let fillet = fillets;\n            let filletCenter = lineLineIntersection(inPoint.add(prevNorm.scale(-fillet)), prevNorm,\n                outPoint.add(nextNorm.scale(-fillet)), nextNorm);\n\n\n            let startRot = getRotFromNormal(prevNorm);\n            let endRot = getRotFromNormal(nextNorm);\n            if (endRot < startRot) {\n                endRot += Math.PI * 2;\n            }\n            let rotStep = (endRot - startRot) / segments;\n\n            for (let i = 0; i <= segments; i++) {\n                outPoints.push(filletCenter.add(getNormalFromRot(startRot + rotStep * i).scale(fillet)));\n            }\n        }\n    }\n\n    if (close) {\n        outPoints.push(outPoints[0]);\n    }\n\n    return outPoints;\n}","import {globals} from './globals.js'\nimport {tuning} from './tuning.js'\n\nexport function createKeyMaterial(name,color) {\n    let mats = globals.renderData.mats;\n    mats[name] = new BABYLON.PBRMetallicRoughnessMaterial(name, globals.scene);\n    mats[name].metallic = 0;\n    mats[name].roughness = 1.0;\n    mats[name].baseColor = color;\n    mats[name].environmentTexture = globals.hdrTexture;\n}\n\nexport function createMaterials() {\n    let mats = globals.renderData.mats;\n    let name = \"keySel\";\n    mats[name] = new BABYLON.StandardMaterial(name, globals.scene);\n    mats[name].diffuseColor = new BABYLON.Color3(0, 0, 0);\n    mats[name].emissiveColor = new BABYLON.Color3(1, 0, 0);\n    mats[name].specularColor = new BABYLON.Color3(0, 0, 0);\n\n    let caseMatName = \"case\";\n    mats[caseMatName] = new BABYLON.PBRMetallicRoughnessMaterial(caseMatName, globals.scene);\n    mats[caseMatName].metallic = 1;\n    mats[caseMatName].roughness = 0.8;\n    mats[caseMatName].baseColor = new BABYLON.Color3(0.6, 0.6, 0.6);\n    mats[caseMatName].environmentTexture = globals.hdrTexture;\n\n    createKeyMaterial(\"key\", new BABYLON.Color3(0.9, 0.9, 0.9));\n}\n\nexport function snapCamera() {\n    const bd = globals.boardData;\n    globals.camera.setTarget(new BABYLON.Vector3(bd.layout.bounds.mins[0] + (bd.layout.bounds.maxs[0] - bd.layout.bounds.mins[0]) / 2.0,\n        0,\n        bd.layout.bounds.mins[1] + (bd.layout.bounds.maxs[1] - bd.layout.bounds.mins[1]) / 2.0));\n    globals.camera.alpha = -Math.PI / 2;\n    globals.camera.beta = 0;\n    globals.camera.radius = 300;\n}\n\nfunction createScene() {\n    const engine = globals.engine;\n\n    // create a basic BJS Scene object\n    var scene = new BABYLON.Scene(engine);\n\n    var camera = new BABYLON.ArcRotateCamera(\"Camera\", -Math.PI / 2, 0, 10, new BABYLON.Vector3(0, 0, 0), scene);\n\n    // target the camera to scene origin\n    camera.setTarget(BABYLON.Vector3.Zero());\n\n    // attach the camera to the canvas\n    camera.attachControl(globals.canvas, false);\n\n    globals.camera = camera;\n\n    // create a basic light, aiming 0,1,0 - meaning, to the sky\n    // var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);\n    // // Default intensity is 1. Let's dim the light a small amount\n    // light.intensity = 0.7;\n    var skyboxPath = \"assets/environment.dds\";\n    globals.hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(skyboxPath, scene);\n    globals.currentSkybox = scene.createDefaultSkybox(globals.hdrTexture, true, (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2, 0.3);\n\n    // return the created scene\n    return scene;\n}\n\nexport function init() {\n    // get the canvas DOM element\n    globals.canvas = document.getElementById('renderCanvas');\n\n    // load the 3D engine\n    globals.engine = new BABYLON.Engine(globals.canvas, true);\n\n    // call the createScene function\n    globals.scene = createScene();\n}\n","import {globals} from './globals.js'\nimport {tuning} from './tuning.js'\nimport * as coremath from './coremath.js'\nimport * as gfx from './gfx.js'\n\nexport function refreshOutlines() {\n    let kRD = globals.renderData.keys;\n    let oRD = globals.renderData.outlines;\n    let mats = globals.renderData.mats;\n\n    for (const [k, o] of Object.entries(oRD)) {\n        globals.scene.removeMesh(o);\n    }\n\n    for (const id of globals.pickedKeys) {\n        if (!kRD[id]) {\n            console.log(\"picked nonexistant key\");\n        }\n        else {\n            let rd = kRD[id];\n\n            oRD[id] = BABYLON.MeshBuilder.CreateRibbon(id + \"outline\",\n                {\n                    pathArray: [coremath.genArrayFromOutline(rd.outline, 0.1, 0.1, true),\n                        coremath.genArrayFromOutline(rd.outline, 0.5, 0.5, true)]\n                }, globals.scene);\n            oRD[id].material = mats[\"keySel\"];\n            oRD[id].translate(new BABYLON.Vector3(0, 10.5, 0), 1, BABYLON.Space.LOCAL);\n        }\n    }\n}\n\nexport function refreshLayout() {\n    const scene = globals.scene;\n    const bd = globals.boardData;\n\n    let mins = [100000.0, 100000.0]\n    let maxs = [-100000.0, -100000.0];\n\n    let bezelHoles = [];\n\n    let kRD = globals.renderData.keys;\n    // clear the renderdata (cache this later?)\n    for(const [id, rd] of Object.entries(kRD)) {\n        if (rd.keycap) {\n            scene.removeMesh(rd.keycap);\n        }\n    }\n    kRD = globals.renderData.keys = [];\n    \n    let outlines = [];\n\n    let kgID = 0;\n    for (const [id, k] of Object.entries(bd.layout.keys)) {\n        // console.log(k);\n\n        if (!kRD[id]) {\n            kRD[id] = {keyGroupId:null,id:id,\n                        mins:[100000.0, 100000.0], maxs:[-100000.0, -100000.0],\n                        bezelMins:[100000.0, 100000.0], bezelMaxs:[-100000.0, -100000.0],\n                        overlappingKeys:{}\n                    };\n        }\n        let rd = kRD[id];\n\n        let keycapDim = [(tuning.keyDims[0] + tuning.base1U[0] * (k.width - 1)) / 2,\n        (tuning.keyDims[1] + tuning.base1U[1] * (k.height - 1)) / 2];\n\n        // let uDim = [(tuning.base1U[0] + tuning.base1U[0] * (k.width - 1)) / 2,\n        // (tuning.base1U[1] + tuning.base1U[1] * (k.height - 1)) / 2];\n\n        let kPos = [k.x * tuning.base1U[0] + keycapDim[0],\n        -(k.y * tuning.base1U[1] + keycapDim[1])]\n        let kPosition = new BABYLON.Vector3(kPos[0], 0, kPos[1]);\n        let kXform = BABYLON.Matrix.Identity();\n        kXform = kXform.multiply(BABYLON.Matrix.Translation(kPos[0], 0, kPos[1]));\n        if (k.rotation_angle != 0) {\n            kXform = kXform.multiply(BABYLON.Matrix.Translation(-k.rotation_x * tuning.base1U[0], 0, k.rotation_y * tuning.base1U[1]));\n            kXform = kXform.multiply(BABYLON.Matrix.RotationY(k.rotation_angle * Math.PI / 180.0))\n            kXform = kXform.multiply(BABYLON.Matrix.Translation(k.rotation_x * tuning.base1U[0], 0, -k.rotation_y * tuning.base1U[1]));\n        }\n        rd.outline = [\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-keycapDim[0], 0, -keycapDim[1]), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(keycapDim[0], 0, -keycapDim[1]), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(keycapDim[0], 0, keycapDim[1]), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-keycapDim[0], 0, keycapDim[1]), kXform)\n        ];\n\n        if (rd.keycap) {\n            scene.removeMesh(rd.keycap);\n        }\n        if (tuning.keyShape) {\n            rd.keycap = BABYLON.MeshBuilder.CreatePolygon(id, { shape: rd.outline, depth: 7, updatable: false }, scene);\n            rd.keycap.translate(new BABYLON.Vector3(0, 10.5, 0), 1, BABYLON.Space.LOCAL);\n    \n            if(k.matName && globals.renderData.mats[k.matName]) {\n                rd.keycap.material = globals.renderData.mats[k.matName];\n            }\n        }\n\n        rd.bezelHole = [\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-keycapDim[0] - tuning.bezelGap, 0, -keycapDim[1] - tuning.bezelGap), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(keycapDim[0] + tuning.bezelGap, 0, -keycapDim[1] - tuning.bezelGap), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(keycapDim[0] + tuning.bezelGap, 0, keycapDim[1] + tuning.bezelGap), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-keycapDim[0] - tuning.bezelGap, 0, keycapDim[1] + tuning.bezelGap), kXform)\n        ];\n        bezelHoles.push(rd.bezelHole);\n\n        for (let p of rd.bezelHole) {\n            rd.bezelMins[0] = Math.min(rd.bezelMins[0], p.x);\n            rd.bezelMaxs[0] = Math.max(rd.bezelMaxs[0], p.x);\n            rd.bezelMins[1] = Math.min(rd.bezelMins[1], p.z);\n            rd.bezelMaxs[1] = Math.max(rd.bezelMaxs[1], p.z);\n        }\n\n        for (let p of rd.outline) {\n            rd.mins[0] = Math.min(rd.mins[0], p.x);\n            rd.maxs[0] = Math.max(rd.maxs[0], p.x);\n            rd.mins[1] = Math.min(rd.mins[1], p.z);\n            rd.maxs[1] = Math.max(rd.maxs[1], p.z);\n        }\n        mins[0] = Math.min(rd.mins[0], mins[0]);\n        maxs[0] = Math.max(rd.maxs[0], maxs[0]);\n        mins[1] = Math.min(rd.mins[1], mins[1]);\n        maxs[1] = Math.max(rd.maxs[1], maxs[1]);\n\n        let checkOverlap = function(k1, rd1, k2, rd2) {\n            if( rd1.bezelMins[0]+BABYLON.Epsilon > rd2.bezelMaxs[0] || rd2.bezelMins[0]+BABYLON.Epsilon > rd1.bezelMaxs[0] ||\n                rd1.bezelMins[1]+BABYLON.Epsilon > rd2.bezelMaxs[1] || rd2.bezelMins[1]+BABYLON.Epsilon > rd1.bezelMaxs[1] ) {\n                return false\n            }\n\n            // see if any of the lines bisect the other rect  (since it's a rect, we know each line is actually a normal of the previous)\n\n            let checkIntersection = (pRD, oRD) => {\n                for(let iP = 0; iP < pRD.bezelHole.length; iP++) {\n                    let line = pRD.bezelHole[(iP+1)%pRD.bezelHole.length].subtract(pRD.bezelHole[iP]);\n                    let allLess = true;\n                    let allMore = true;\n                    for(let oP = 0; oP < oRD.bezelHole.length; oP++) {\n                        let dot = BABYLON.Vector3.Dot(line,oRD.bezelHole[oP].subtract(pRD.bezelHole[iP]));\n                        allMore &= dot > -BABYLON.Epsilon;\n                        allLess &= dot < BABYLON.Epsilon;\n                    }\n    \n                    if( allMore || allLess ) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            let confirmedIntersection = checkIntersection(rd1,rd2);\n            if(!confirmedIntersection) {\n                confirmedIntersection = checkIntersection(rd2,rd1);\n            }\n\n            if(confirmedIntersection) {\n                rd1.overlappingKeys[rd2.id] = rd2;\n                rd2.overlappingKeys[rd1.id] = rd1;\n                if(rd1.keyGroupId && rd2.keyGroupId) {\n                    // merge\n                    // console.log(`merging kgIDs ${rd1.keyGroupId} and ${rd2.keyGroupId}`);\n                    let pKG = rd1.keyGroupId;\n                    let oKG = rd2.keyGroupId;\n                    for(const [otherId, oRD] of Object.entries(kRD)) {\n                        if(oRD.keyGroupId == oKG) {\n                            oRD.keyGroupId = pKG;\n                        }\n                    }\n                }\n                else if(rd1.keyGroupId) {\n                    rd2.keyGroupId = rd1.keyGroupId;\n                }\n                else if(rd2.keyGroupId) {\n                    rd1.keyGroupId = rd2.keyGroupId;\n                }\n                else {\n                    rd1.keyGroupId = rd2.keyGroupId = kgID++;\n                }\n            }\n        }\n\n        for (const [otherId, otherRD] of Object.entries(kRD)) {\n            if(otherId == id) {\n                continue;\n            }\n\n            let otherKey = bd.layout.keys[otherId];\n            checkOverlap(k,rd,otherKey,otherRD);\n        }\n\n        if(!rd.keyGroupId) {\n            rd.keyGroupId = kgID++;\n        }\n    }\n\n    bd.layout.bounds = { mins: mins, maxs: maxs };\n\n    refreshOutlines();\n}\n\n\nexport function refreshCase() {\n    const scene = globals.scene;\n    const bd = globals.boardData;\n    const kRD = globals.renderData.keys;\n    const mats = globals.renderData.mats;\n\n    let funFunc = (primeL, primeLen, otherLen, line, norm, distBetween, lineArray, parseArray) => {\n        if(!parseArray[primeL]) {\n            let primeToOtherNear = Math.max(distBetween - otherLen,0) / primeLen;\n            let primeToOtherFar = distBetween / primeLen;\n            if(primeToOtherNear < 1 - BABYLON.Epsilon && primeToOtherFar > BABYLON.Epsilon) {\n                // kill O and replace it with any remaining line segments\n                parseArray[primeL] = true;\n                if (primeToOtherNear > BABYLON.Epsilon) {\n                    lineArray.push([line[0],line[0].add(norm.scale(distBetween - otherLen))]);\n                }\n                if (primeToOtherFar < 1 - BABYLON.Epsilon) {\n                    lineArray.push([line[0].add(norm.scale(distBetween)), line[1]]);\n                }\n            }\n        }\n    }\n\n    if(bd.caseType == \"convex\") {\n        let kPs = [];\n        for( let [id,rd] of Object.entries(kRD) ) {\n            for( let p of rd.outline ) {\n                kPs.push(p)\n            }\n        }\n        bd.outline = coremath.convexHull2d(kPs);\n\n        if(bd.forceSymmetrical) {\n            let midPoint = (bd.layout.bounds.maxs[0] - bd.layout.bounds.mins[0]) * 0.5 + bd.layout.bounds.mins[0];\n            for(let oP of bd.outline) {\n                kPs.push(new BABYLON.Vector3(midPoint - (oP.x - midPoint), oP.y, oP.z));\n            }\n            bd.outline = coremath.convexHull2d(kPs);\n        }\n    }\n    else\n    {\n        let bounds = bd.layout.bounds;\n        bd.outline = [\n            new BABYLON.Vector3(bounds.mins[0], 0, bounds.mins[1]),\n            new BABYLON.Vector3(bounds.maxs[0], 0, bounds.mins[1]),\n            new BABYLON.Vector3(bounds.maxs[0], 0, bounds.maxs[1]),\n            new BABYLON.Vector3(bounds.mins[0], 0, bounds.maxs[1])\n        ];\n    }\n\n    let cRD = globals.renderData.case;\n\n    let cavityInnerEdge = [coremath.genArrayFromOutline(bd.outline, tuning.bezelGap, tuning.bezelCornerFillet, false)];\n    let caseFrame = coremath.genArrayFromOutline(bd.outline, tuning.bezelGap + tuning.bezelThickness, tuning.bezelThickness, false, 8);\n\n    if (cRD.edge) {\n        scene.removeMesh(cRD.edge);\n    }\n    if( tuning.drawCase ) {\n        cRD.edge = BABYLON.MeshBuilder.CreatePolygon(\"edge\", { shape: caseFrame, depth:9, holes: cavityInnerEdge, updatable: true }, scene);\n        cRD.edge.material = mats[\"case\"];\n    }\n\n    if (cRD.bottom) {\n        scene.removeMesh(cRD.bottom);\n    }\n    if( tuning.drawCase ) {\n        cRD.bottom = BABYLON.MeshBuilder.CreatePolygon(\"bottom\", { shape: caseFrame, depth:3, updatable: true }, scene);\n        cRD.bottom.translate(new BABYLON.Vector3(0, -9, 0), 1, BABYLON.Space.LOCAL);\n        cRD.bottom.material = mats[\"case\"];\n    }\n\n\n    let keyGroups = {};\n    let bezelOutlines = [];\n    for(const [otherId, oRD] of Object.entries(kRD)) {\n        // console.log(`kgid: ${oRD.keyGroupId}`);\n        if(!keyGroups[oRD.keyGroupId]) {\n            keyGroups[oRD.keyGroupId] = [];\n        }\n        keyGroups[oRD.keyGroupId].push(oRD);\n    }\n    for(const [kgId, KG] of Object.entries(keyGroups)) {\n        for( const rd of KG ) {\n            rd.outlineLines = [];\n            rd.parsedOutlineLines = {};\n            for(let p = 0; p < rd.bezelHole.length; p++) {\n                let lStart = rd.bezelHole[p];\n                let lEnd = rd.bezelHole[(p+1)%rd.bezelHole.length]\n                rd.outlineLines.push([lStart,lEnd]);\n            }\n\n            for( const [oId,otherRD] of Object.entries(rd.overlappingKeys) ) {\n                for(let iL = rd.outlineLines.length - 1; iL >= 0; iL--) {\n                    let l = rd.outlineLines[iL];\n                    let lL = l[1].subtract(l[0]);\n                    let lNorm = new BABYLON.Vector3(lL.z,0,-lL.x).normalize();\n                    let isStartInPoly = coremath.isPointInPoly(l[0],otherRD.bezelHole);\n                    let isEndInPoly = coremath.isPointInPoly(l[1],otherRD.bezelHole)\n                    if(isStartInPoly) {\n                        if(isEndInPoly) {\n                            // both are inside the poly, just remove the line\n                            // console.log(`removing line ${iL} from ${rd.id}`);\n                            rd.outlineLines.splice(iL, 1);\n                        }\n                        let minExitT = 100000.0;\n                        let bestIntersection = null;\n                        for(let iOP = 0; iOP < otherRD.bezelHole.length; iOP++) {\n                            let intersection = coremath.rayToSegment(l[0], lL, lNorm, otherRD.bezelHole[iOP], otherRD.bezelHole[(iOP+1)%otherRD.bezelHole.length]);\n                            if(intersection) {\n                                let t = intersection.subtract(l[0]).lengthSquared();\n                                if( t > BABYLON.Epsilon && t < minExitT ) {\n                                    minExitT = t;\n                                    bestIntersection = intersection;\n                                }\n                            }\n                        }\n                        if (bestIntersection) {\n                            // console.log(`trimming line ${iL} from ${rd.id} to ${minExitT}`);\n                            l[0] = bestIntersection;\n                        }\n                        // else { console.log(`FAILED TO TRIM ${iL} from ${rd.id}`); }\n                    }\n                    else if(isEndInPoly) {\n                        let revLine = l[0].subtract(l[1])\n                        let revNorm = new BABYLON.Vector3(revLine.z,0,-revLine.x).normalize();\n                        let minExitT = 100000.0;\n                        let bestIntersection = null;\n                        for(let iOP = 0; iOP < otherRD.bezelHole.length; iOP++) {\n                            let intersection = coremath.rayToSegment(l[1], revLine, revNorm, otherRD.bezelHole[iOP], otherRD.bezelHole[(iOP+1)%otherRD.bezelHole.length]);\n                            if( intersection ) {\n                                let t = intersection.subtract(l[1]).lengthSquared();\n                                if( t > BABYLON.Epsilon && t < minExitT ) {\n                                    minExitT = t;\n                                    bestIntersection = intersection;\n                                }\n                            }\n                        }\n                        if (bestIntersection) {\n                            // console.log(`rev trimming line ${iL} from ${rd.id} to ${minExitT}`);\n                            l[1] = bestIntersection;\n                        }\n                        // else { console.log(`FAILED TO REV TRIM ${iL} from ${rd.id}`); }\n                    }\n                    else {\n                        // else neither end is in the poly and we should do full seg->seg checks if we're worried about this\n                    }\n                }\n            }\n        }\n        let maxOverlapSq = tuning.bezelGap*tuning.bezelGap + BABYLON.Epsilon;\n\n        // clip any overlapping parallel lines against each other (cancel if they face each other)\n        for( const rd of KG ) {\n            rd.visitedForOutline = true;\n            let ilMax = rd.outlineLines.length;\n            for(let iL = 0; iL < ilMax; iL++) {\n                let lL = rd.outlineLines[iL];\n                let lDir = lL[1].subtract(lL[0]);\n                let lLen = lDir.length()\n                if(lLen < BABYLON.Epsilon) continue;\n                let lineNorm = lDir.normalizeFromLength(lLen);\n\n                for( const [oId,otherRD] of Object.entries(rd.overlappingKeys) ) {\n                    if(otherRD.visitedForOutline) continue;\n\n                    let jLMax = otherRD.outlineLines.length;\n                    for( let jL = 0; jL < jLMax; jL++ ) {\n                        let oL = otherRD.outlineLines[jL];\n                        let oDir = oL[1].subtract(oL[0]);\n                        let oLen = oDir.length();\n                        if(oLen < BABYLON.Epsilon ) continue;\n                        let oLNorm = oDir.normalizeFromLength(oLen);\n                        // check to see if these two are facing away from each other\n                        let lineDot = BABYLON.Vector3.Dot(oLNorm,lineNorm)\n                        if( lineDot < BABYLON.Epsilon-1 || lineDot > 1-BABYLON.Epsilon) {\n                            let diff = lL[0].subtract(oL[0]);\n                            let dd = BABYLON.Vector3.Dot(diff, oLNorm);\n                            let projPoint = oL[0].add(oLNorm.scale(dd))\n                            if( projPoint.subtract(lL[0]).lengthSquared() < maxOverlapSq) {\n                                if(lineDot < BABYLON.Epsilon-1) {\n                                    // at this point, dd is the distance between the two starting points (which are facing each other) \n                                    // erase the overlapping portion of each line\n                                    // O ------------> olen\n                                    //      llen <--------- L\n                                    // O <----------------> dd\n                                    overlapFunc(jL,oLen,lLen,oL,oLNorm,dd,otherRD.outlineLines,otherRD.parsedOutlineLines);\n                                    overlapFunc(iL,lLen,oLen,lL,lineNorm,dd,rd.outlineLines,rd.parsedOutlineLines);\n                                }\n                                else if( lineDot > 1-BABYLON.Epsilon ) {\n                                    if( dd > BABYLON.Epsilon ) {\n                                        // O -------->\n                                        //        L ---------->\n                                        // O <---> dd\n                                        // consume L\n                                        let overlapDist = oLen - dd;\n                                        if(!rd.parsedOutlineLines[iL]) {\n                                            if(overlapDist > BABYLON.Epsilon) {\n                                                rd.parsedOutlineLines[iL] = true;\n                                                rd.outlineLines.push([lL[0].add(lineNorm.scale(overlapDist)),lL[1]]);\n                                            }\n                                        }\n                                    }\n                                    if( dd < BABYLON.Epsilon ) {\n                                        // L -------->\n                                        //        O ---------->\n                                        // L <---> -dd\n                                        // consume L\n                                        let overlapDist = -dd;\n                                        if(!rd.parsedOutlineLines[iL]) {\n                                            if(overlapDist < lLen - BABYLON.Epsilon) {\n                                                rd.parsedOutlineLines[iL] = true;\n                                                rd.outlineLines.push([lL[0],lL[0].add(lineNorm.scale(overlapDist))]);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        let parsedLines = [];\n        let nextKeyRd = null;\n        let nextLineIndex = -1;\n        let invertNextLine = false;\n        // pick a line at random.  this could actually pick something on an interior island so we should probably\n        // run the loop gen algorithm until all the lines are used up and then pick the polygon with the largest area\n        for( const rd of KG ) {\n            for(let iL = 0; iL < rd.outlineLines.length; iL++) {\n                if(!rd.parsedOutlineLines[iL]) {\n                    nextKeyRd = rd;\n                    nextLineIndex = iL;\n                    break;\n                }\n            }\n            if(nextLineIndex >= 0) break;\n        }\n\n        let outline = [];\n        // finally, walk through the list of available outline lines and pick the closest end point for the next line\n        while(nextKeyRd != null && nextLineIndex >= 0) {\n            nextKeyRd.parsedOutlineLines[nextLineIndex] = true;\n            let prevLine = nextKeyRd.outlineLines[nextLineIndex];\n            if(invertNextLine) {\n                let tmp = prevLine[0];\n                prevLine[0] = prevLine[1];\n                prevLine[1] = tmp;\n            }\n\n            outline.push(prevLine[0]);\n\n            parsedLines.push(prevLine);\n            nextLineIndex = -1;\n            let nextDistSq = 1000000.0\n\n            let checkNext = (n,nRd,i) => {\n                let newDistSq = prevLine[1].subtract(n[0]).lengthSquared();\n                if(newDistSq < nextDistSq) {\n                    nextDistSq = newDistSq;\n                    nextKeyRd = nRd;\n                    nextLineIndex = i;\n                    invertNextLine = false;\n                }\n\n                newDistSq = prevLine[1].subtract(n[1]).lengthSquared();\n                if(newDistSq < nextDistSq) {\n                    nextDistSq = newDistSq;\n                    nextKeyRd = nRd;\n                    nextLineIndex = i;\n                    invertNextLine = true;\n                }\n            }\n            \n            for(let iL = 0; iL < nextKeyRd.outlineLines.length; iL++) {\n                if(!nextKeyRd.parsedOutlineLines[iL]) {\n                    checkNext(nextKeyRd.outlineLines[iL],nextKeyRd,iL);\n                }\n            }\n\n            for( const [oId,otherRD] of Object.entries(nextKeyRd.overlappingKeys) ) {\n                for( let jL = 0; jL < otherRD.outlineLines.length; jL++ ) {\n                    if(otherRD.parsedOutlineLines[jL]) continue;\n\n                    checkNext(otherRD.outlineLines[jL],otherRD,jL);\n                }\n            }\n        }\n        bezelOutlines.push(coremath.genArrayFromOutline(outline,0.0,tuning.bezelCornerFillet,false));\n    }\n    \n    if (cRD.bezel) {\n        scene.removeMesh(cRD.bezel);\n    }\n    if( tuning.drawCase ) {\n        cRD.bezel = BABYLON.MeshBuilder.CreatePolygon(\"bezel\", { shape: caseFrame, depth:7.5, holes: bezelOutlines }, scene);\n        cRD.bezel.translate(new BABYLON.Vector3(0, 7.5, 0), 1, BABYLON.Space.LOCAL);\n        //cRD.bezel.rotation = new BABYLON.Vector3(-Math.PI/12, 0, 0);\n        cRD.bezel.material = mats[\"case\"];\n    }\n}\n\nexport function refreshKeyboard() {\n    refreshLayout();\n\n    refreshCase();\n}\n\nexport function loadKeyboard() {\n    fetch('testkbs/basis-mono.kle')\n        .then(response => response.json())\n        .then(data => {\n            // console.log(data);\n            let mats = globals.renderData.mats;\n\n            let bd = {};\n            bd.meta = data.meta;\n            bd.case = data.case;\n            bd.layout = {keys: {}};\n            let kIdx = 0\n            for (let k of data.keys) {\n                k.id = \"key\" + kIdx++;\n                \n                if(!mats[k.color]) {\n                    gfx.createKeyMaterial(k.color,BABYLON.Color3.FromHexString(k.color));\n                }\n                k.matName = k.color;\n                \n                bd.layout.keys[k.id] = k;\n            }\n            globals.boardData = bd;\n            \n            gfx.createMaterials();\n            refreshKeyboard();\n            gfx.snapCamera();\n        });\n}\n","import {globals} from './globals.js'\nimport * as boardOps from './boardOps.js'\n\nexport const kbgbGUI = {\n    addButton: function(txt, action, style) {\n        style = style?style:{};\n        var button = BABYLON.GUI.Button.CreateSimpleButton(\"button\", txt);\n        button.top = \"0px\";\n        button.left = \"0px\";\n        button.width = style.width?style.width:\"60px\";\n        button.height = style.height?style.height:\".4\";\n        button.cornerRadius = 5;\n        button.thickness = 2;\n        button.children[0].color = \"#DFF9FB\";\n        button.children[0].fontSize = 24;\n        button.color = \"#FF7979\";\n        button.background = \"#EB4D4B\";\n        //button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    \n        button.onPointerClickObservable.add(action);\n    \n        return button;\n    },\n    addLabel: function(txt) {\n        var t = new BABYLON.GUI.TextBlock();\n        t.width = \"80px\";\n        t.height = \".9\";\n        t.text = txt;\n        t.color = \"white\";\n        t.fontSize = 24;\n        return t;\n    },\n    addKeyActionButton: function(txt, keyAction) {\n        return kbgbGUI.addButton(txt, function () {\n            for (let kId of globals.pickedKeys) {\n                let bd = globals.boardData;\n                let k = bd.layout.keys[kId];\n                keyAction(k);\n            }\n            boardOps.refreshKeyboard();\n        }); \n    },\n    modes:{\n        \"key\":{\n            add: function() {\n                //let ctrlBar = BABYLON.GUI.Control.AddHeader(control, text, size, options { isHorizontal, controlFirst }):\n                let ctrlBar = new BABYLON.GUI.StackPanel();  \n                ctrlBar.height = \".2\";\n                ctrlBar.isPointerBlocker = true;\n                ctrlBar.isVertical = false;\n                //ctrlBar.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n                ctrlBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n            \n                ctrlBar.addControl(kbgbGUI.addLabel(\"Pos: \"));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`◄`, (k) => k.x -= 0.25 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`▲`, (k) => k.y -= 0.25 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`▼`, (k) => k.y += 0.25 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`►`, (k) => k.x += 0.25 ));\n            \n            \n                ctrlBar.addControl(kbgbGUI.addLabel(\"Rot: \"));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⤹`, (k) => k.rotation_angle -= 5 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⤸`, (k) => k.rotation_angle += 5 ));\n            \n                ctrlBar.addControl(kbgbGUI.addLabel(\"W: \"));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⬌`, (k) => k.width += 0.25 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⬄`, (k) => k.width -= 0.25 ));\n            \n                ctrlBar.addControl(kbgbGUI.addLabel(\"H: \"));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⬍`, (k) => k.height += 0.25 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⇳`, (k) => k.height -= 0.25 ));\n                \n                globals.screengui.addControl(ctrlBar);\n                kbgbGUI.activeModeCtrl = ctrlBar;\n            }\n        },\n        \"case\":{\n            add: function() {\n                //let ctrlBar = BABYLON.GUI.Control.AddHeader(control, text, size, options { isHorizontal, controlFirst }):\n                let ctrlBar = new BABYLON.GUI.StackPanel();  \n                ctrlBar.height = \".2\";\n                ctrlBar.isPointerBlocker = true;\n                ctrlBar.isVertical = false;\n                ctrlBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n            \n                ctrlBar.addControl(kbgbGUI.addLabel(\"Type: \"));\n\n                var addRadio = function(text, parent) {\n\n                    var button = new BABYLON.GUI.RadioButton();\n                    button.width = \"20px\";\n                    button.height = \"20px\";\n                    button.color = \"white\";\n                    button.background = \"green\";     \n            \n                    button.onIsCheckedChangedObservable.add(function(state) {\n                        if(state) {\n                            globals.boardData.caseType = text;\n                            boardOps.refreshCase()\n                        }\n                    }); \n            \n                    var header = BABYLON.GUI.Control.AddHeader(button, text, \"100px\", { isHorizontal: true, controlFirst: true });\n                    header.height = \"30px\";\n            \n                    parent.addControl(header);    \n                }\n            \n            \n                let radioCtrl = new BABYLON.GUI.StackPanel();  \n                radioCtrl.height = \"1\";\n                radioCtrl.width = \"200px\";\n                radioCtrl.isVertical = true;\n                addRadio(\"rectangle\", radioCtrl);\n                addRadio(\"convex\", radioCtrl);\n                addRadio(\"concave\", radioCtrl);\n                ctrlBar.addControl(radioCtrl);\n\n                var checkbox = new BABYLON.GUI.Checkbox();\n                checkbox.width = \"20px\";\n                checkbox.height = \"20px\";\n                checkbox.isChecked = false;\n                checkbox.color = \"green\";\n                checkbox.onIsCheckedChangedObservable.add(function(value) {\n                    globals.boardData.forceSymmetrical = value;\n                    boardOps.refreshCase();\n                });\n\n                ctrlBar.addControl(kbgbGUI.addLabel(\"SYM: \"));\n                ctrlBar.addControl(checkbox);\n\n                globals.screengui.addControl(ctrlBar);\n                kbgbGUI.activeModeCtrl = ctrlBar;\n            }\n        }\n    },\n    setGUIMode: function(mode) {\n        if(kbgbGUI.activeModeCtrl) {\n            globals.screengui.removeControl(kbgbGUI.activeModeCtrl);\n        }\n        if(kbgbGUI.modes[mode]) {\n            kbgbGUI.modes[mode].add();\n        }\n    },\n    addModeGUI: function() {\n        let ctrlBar = new BABYLON.GUI.StackPanel();  \n        ctrlBar.height = \".1\";\n        ctrlBar.isPointerBlocker = true;\n        ctrlBar.isVertical = false;\n        //ctrlBar.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n        ctrlBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n        ctrlBar.addControl(kbgbGUI.addButton(\"layout\", () => {kbgbGUI.setGUIMode(\"key\")}, {height:\"1\",width:\"120px\"}));\n        ctrlBar.addControl(kbgbGUI.addButton(\"case\", () => {kbgbGUI.setGUIMode(\"case\")}, {height:\"1\",width:\"120px\"}));\n        ctrlBar.addControl(kbgbGUI.addButton(\"pcb\", () => {kbgbGUI.setGUIMode(\"pcb\")}, {height:\"1\",width:\"120px\"}));\n        ctrlBar.addControl(kbgbGUI.addButton(\"deets\", () => {kbgbGUI.setGUIMode(\"details\")}, {height:\"1\",width:\"120px\"}));\n\n        kbgbGUI.modeCtrl = ctrlBar;\n        globals.screengui.addControl(ctrlBar);\n    }\n}","import {globals} from './globals.js'\nimport {tuning} from './tuning.js'\nimport {kbgbGUI} from './ui.js'\nimport * as boardOps from './boardOps.js'\nimport * as gfx from './gfx.js'\n\nfunction initKBGB() {\n    gfx.init();\n\n    globals.screengui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"screenUI\");\n\n    kbgbGUI.addModeGUI();\n\n    // run the render loop\n    globals.engine.runRenderLoop(function () {\n        globals.scene.render();\n    });\n\n\n    // load a keyboard\n    boardOps.loadKeyboard();\n\n    // the canvas/window resize event handler\n    window.addEventListener('resize', function () {\n        globals.engine.resize();\n    });\n\n    window.addEventListener('keydown', event => {\n        if( event.key == 'i' ) {\n            if(globals.scene.debugLayer.isVisible()) {\n                globals.scene.debugLayer.hide();\n            } else {\n                globals.scene.debugLayer.show();\n            }\n        }\n        if( event.key == 'k' ) {\n            tuning.keyShape = tuning.keyShape?null:\"square\";\n            boardOps.refreshKeyboard();\n        }\n        if( event.key == 'c' ) {\n            tuning.drawCase = tuning.drawCase?false:true;\n            boardOps.refreshKeyboard();\n        }\n    })\n}\n\nwindow.addEventListener('DOMContentLoaded', function () {\n    initKBGB();\n});\n\n\n\n//When click event is raised\nwindow.addEventListener(\"click\", function (e) {\n    const scene = globals.scene;\n    var pickResult = scene.pick(scene.pointerX, scene.pointerY);\n    //console.log(pickResult);\n    if (pickResult && pickResult.pickedMesh) {\n        if (globals.boardData.layout.keys[pickResult.pickedMesh.name]) {\n            let pickedKeys = globals.pickedKeys;\n            if (e.metaKey || e.ctrlKey) {\n                if (globals.pickedKeys.indexOf(pickResult.pickedMesh.name) > 0) {\n                    globals.pickedKeys.splice(globals.pickedKeys.indexOf(pickResult.pickedMesh.name), 1)\n                }\n                else {\n                    globals.pickedKeys.push(pickResult.pickedMesh.name)\n                }\n            }\n            else {\n                globals.pickedKeys = [pickResult.pickedMesh.name];\n            }\n            console.log(\"picked key \" + pickResult.pickedMesh.name)\n            boardOps.refreshOutlines();\n        }\n    }\n});"],"names":["globals","pickedKeys","renderData","keys","case","mats","outlines","tuning","keyDims","switchCutout","base1U","bezelGap","bezelThickness","bezelCornerFillet","keyShape","drawCase","lineLineIntersection","p0","d0","p1","d1","det","x","z","BABYLON","Epsilon","prevC","nextC","Vector3","rayToSegment","x0","xL","xNorm","y0","y1","yL","subtract","intersection","normalize","intLenSq","lengthSquared","isPointInPoly","p","poly","i","length","point","nextDir","nextNorm","pV","Dot","getRotFromNormal","norm","t","Math","acos","PI","orient","a","b","c","s","l","r","tol","convexHull2d","points","n","result","Array","sorted","sort","d","lower","upper","idx","m","pop","push","ptr","nl","j","pList","unshift","genArrayFromOutline","outline","offset","fillets","close","segments","outPoints","next","prev","prevDir","prevNorm","inPoint","add","scale","outPoint","fillet","filletCenter","startRot","endRot","rotStep","rot","cos","sin","createKeyMaterial","name","color","PBRMetallicRoughnessMaterial","scene","metallic","roughness","baseColor","environmentTexture","hdrTexture","init","canvas","document","getElementById","engine","Engine","Scene","camera","ArcRotateCamera","setTarget","Zero","attachControl","CubeTexture","CreateFromPrefilteredData","currentSkybox","createDefaultSkybox","activeCamera","maxZ","minZ","createScene","refreshOutlines","kRD","oRD","k","o","Object","entries","removeMesh","id","rd","MeshBuilder","CreateRibbon","pathArray","coremath.genArrayFromOutline","material","translate","Space","LOCAL","console","log","refreshCase","bd","boardData","caseType","kPs","coremath.convexHull2d","forceSymmetrical","midPoint","layout","bounds","maxs","mins","oP","y","cRD","cavityInnerEdge","caseFrame","edge","CreatePolygon","shape","depth","holes","updatable","bottom","keyGroups","bezelOutlines","otherId","keyGroupId","kgId","KG","outlineLines","parsedOutlineLines","bezelHole","lStart","lEnd","oId","otherRD","overlappingKeys","iL","lL","lNorm","isStartInPoly","coremath.isPointInPoly","isEndInPoly","splice","minExitT","bestIntersection","iOP","coremath.rayToSegment","revLine","revNorm","maxOverlapSq","visitedForOutline","ilMax","lDir","lLen","lineNorm","normalizeFromLength","jLMax","jL","oL","oDir","oLen","oLNorm","lineDot","diff","dd","overlapFunc","overlapDist","nextKeyRd","nextLineIndex","invertNextLine","prevLine","tmp","nextDistSq","checkNext","nRd","newDistSq","bezel","refreshKeyboard","bezelHoles","keycap","kgID","bezelMins","bezelMaxs","keycapDim","width","height","kPos","kXform","Matrix","Identity","multiply","Translation","rotation_angle","rotation_x","rotation_y","RotationY","TransformCoordinates","matName","min","max","checkOverlap","k1","rd1","k2","rd2","checkIntersection","pRD","iP","line","allLess","allMore","dot","confirmedIntersection","pKG","oKG","refreshLayout","loadKeyboard","fetch","then","response","json","data","meta","kIdx","gfx.createKeyMaterial","Color3","FromHexString","StandardMaterial","diffuseColor","emissiveColor","specularColor","caseMatName","gfx.createMaterials","alpha","beta","radius","gfx.snapCamera","kbgbGUI","addButton","txt","action","style","button","GUI","Button","CreateSimpleButton","top","left","cornerRadius","thickness","children","fontSize","background","onPointerClickObservable","addLabel","TextBlock","text","addKeyActionButton","keyAction","kId","boardOps.refreshKeyboard","modes","key","ctrlBar","StackPanel","isPointerBlocker","isVertical","verticalAlignment","Control","VERTICAL_ALIGNMENT_BOTTOM","addControl","screengui","activeModeCtrl","addRadio","parent","RadioButton","onIsCheckedChangedObservable","state","boardOps.refreshCase","header","AddHeader","isHorizontal","controlFirst","radioCtrl","checkbox","Checkbox","isChecked","value","setGUIMode","mode","removeControl","addModeGUI","VERTICAL_ALIGNMENT_TOP","modeCtrl","window","addEventListener","gfx.init","AdvancedDynamicTexture","CreateFullscreenUI","runRenderLoop","render","boardOps.loadKeyboard","resize","event","debugLayer","isVisible","hide","show","e","pickResult","pick","pointerX","pointerY","pickedMesh","metaKey","ctrlKey","indexOf","boardOps.refreshOutlines"],"mappings":"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"}