{"version":3,"file":"pack.js","sources":["../../src/globals.js","../../src/tuning.js","../../src/coremath.js","../../src/gfx.js","../../src/boardOps.js","../../src/svg_export.js","../../src/ui.js","../../src/base.js"],"sourcesContent":["export const globals = {\n    pickedKeys: [],\n    renderData: { keys: {}, case: {}, mats: {}, outlines: {} },\n    boardData: {}\n}","export const tuning = {\n    keyDims: [18.0, 18.0],\n    switchCutout: [14.0, 14.0],\n    base1U: [19.05, 19.05],\n    bezelGap: 1.05,\n    bezelThickness: 8,\n    caseCornerFillet: 8,\n    bezelCornerFillet: 0.5,\n    keyShape:\"square\",\n    drawCase:true,\n    drawBezel:true,\n    drawPlate:true,\n    drawPCB:true\n}","\nexport function lineLineIntersection(p0, d0, p1, d1) {\n    let det = d0.x * d1.z - d1.x * d0.z;\n    if (Math.abs(det) < BABYLON.Epsilon) // no collision\n    {\n        return null;\n    }\n\n    let prevC = p0.x * d0.x + p0.z * d0.z;\n    let nextC = p1.x * d1.x + p1.z * d1.z;\n    let intersection = new BABYLON.Vector3((d1.z * prevC - d0.z * nextC) / det, 0,\n        (d0.x * nextC - d1.x * prevC) / det);\n\n    return intersection;\n}\n\nfunction pointToLineDistSq(x0, xL, y0) {\n    let dir = y0.subtract(x0);\n    let xNormalized = xL.normalizeToNew();\n    let dot = BABYLON.Vector3.Dot(dir,xNormalized);\n\n    let nearestPoint = x0.add(xNormalized.scale(dot));\n    return y0.subtract(nearestPoint).lengthSquared();\n}\n\nexport function segmentToSegment(x0, x1, xL, xNorm, y0, y1) {\n    //let xL = x1.subtract(x0);\n    let yL = y1.subtract(y0);\n    //let xNorm = (new BABYLON.Vector3(xL.z, 0, -xL.x)).normalize();\n    let yNorm = (new BABYLON.Vector3(yL.z, 0, -yL.x)).normalize();\n\n    let result = {intersection: lineLineIntersection(x0,xNorm,y0,yNorm),\n                  type:\"unknown\"}\n    if(result.intersection) {\n        let y0Dot = BABYLON.Vector3.Dot(result.intersection.subtract(y0),yL);\n        let y1Dot = BABYLON.Vector3.Dot(result.intersection.subtract(y1),yL);\n        let x0Dot = BABYLON.Vector3.Dot(result.intersection.subtract(x0),xL);\n        let x1Dot = BABYLON.Vector3.Dot(result.intersection.subtract(x1),xL);\n        if(y0Dot > -BABYLON.Epsilon && y1Dot < BABYLON.Epsilon &&\n           x0Dot > -BABYLON.Epsilon && x1Dot < BABYLON.Epsilon) {\n            result.type = \"in_segment\";\n        } else {\n            result.type = \"off_segment\";\n        }\n    } else {\n        if(pointToLineDistSq(x0,xL,y0) < BABYLON.Epsilon) {\n            result.type = \"colinear\"\n            // check overlap?\n            // let y0In = (BABYLON.Vector3.Dot(y0.subtract(x0),xL) > -BABYLON.Epsilon && BABYLON.Vector3.Dot(y0.subtract(x1),xL) < BABYLON.Epsilon);\n            // let y1In = (BABYLON.Vector3.Dot(y1.subtract(x0),xL) > -BABYLON.Epsilon && BABYLON.Vector3.Dot(y1.subtract(x1),xL) < BABYLON.Epsilon);\n            // let x0In = (BABYLON.Vector3.Dot(x0.subtract(y0),yL) > -BABYLON.Epsilon && BABYLON.Vector3.Dot(x0.subtract(y1),yL) < BABYLON.Epsilon);\n            // let x1In = (BABYLON.Vector3.Dot(x1.subtract(y0),yL) > -BABYLON.Epsilon && BABYLON.Vector3.Dot(x1.subtract(y1),yL) < BABYLON.Epsilon);\n            // if(y0In || x0In || y1In || x1In) {\n            //     result.type = \"colinear_OVERLAPPING\"\n            // }\n        } else {\n            result.type = \"parallel\"\n        }\n    }\n    return result;\n}\n\n// only convex\nexport function isPointInPoly(p, poly) {\n    for(let i = 0; i < poly.length; i++) {\n        let point = poly[i];\n        let next = poly[(i + 1) % poly.length];\n        let nextDir = next.subtract(point).normalize();\n        let nextNorm = new BABYLON.Vector3(nextDir.z, 0, -nextDir.x);\n        let pV = p.subtract(point).normalize();\n        let d = BABYLON.Vector3.Dot(pV,nextNorm)\n        if( d > BABYLON.Epsilon) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function getRotFromNormal(norm) {\n    let t = Math.acos(norm.x);\n    if (norm.z < 0) t = 2 * Math.PI - t;\n    return t;\n}\n\nexport function getNormalFromRot(rot) {\n    return new BABYLON.Vector3(Math.cos(rot), 0, Math.sin(rot));\n}\n\nvar EPSILON     = 1.1102230246251565e-16\nvar ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON\nfunction orient(a, b, c) {\n    var l = (a.z - c.z) * (b.x - c.x)\n    var r = (a.x - c.x) * (b.z - c.z)\n    var det = l - r\n    var s\n    if(l > 0) {\n      if(r <= 0) {\n        return det\n      } else {\n        s = l + r\n      }\n    } else if(l < 0) {\n      if(r >= 0) {\n        return det\n      } else {\n        s = -(l + r)\n      }\n    } else {\n      return det\n    }\n    var tol = ERRBOUND3 * s\n    if(det >= tol || det <= -tol) {\n      return det\n    }\n    return 0\n  }\n\n// convex hull of points on the x/z plane\nexport function convexHull2d(points) {\n    var n = points.length\n\n    if (n < 3) {\n        var result = new Array(n)\n        for (var i = 0; i < n; ++i) {\n            result[i] = i\n        }\n\n        if (n === 2 &&\n            points[0].x === points[1].x &&\n            points[0].z === points[1].z) {\n            return [0]\n        }\n\n        return result\n    }\n\n    //Sort point indices along x-axis\n    var sorted = new Array(n)\n    for (var i = 0; i < n; ++i) {\n        sorted[i] = i\n    }\n    sorted.sort(function (a, b) {\n        var d = points[a].x - points[b].x\n        if (d) {\n            return d\n        }\n        return points[a].z - points[b].z\n    })\n\n    //Construct upper and lower hulls\n    var lower = [sorted[0], sorted[1]]\n    var upper = [sorted[0], sorted[1]]\n\n    for (var i = 2; i < n; ++i) {\n        var idx = sorted[i]\n        var p = points[idx]\n\n        //Insert into lower list\n        var m = lower.length\n        while (m > 1 && orient(\n                                points[lower[m - 2]],\n                                points[lower[m - 1]],\n                                p) <= 0) {\n            m -= 1\n            lower.pop()\n        }\n        lower.push(idx)\n\n        //Insert into upper list\n        m = upper.length\n        while (m > 1 && orient(\n            points[upper[m - 2]],\n            points[upper[m - 1]],\n            p) >= 0) {\n            m -= 1\n            upper.pop()\n        }\n        upper.push(idx)\n    }\n\n    //Merge lists together\n    var result = new Array(upper.length + lower.length - 2)\n    var ptr = 0\n    for (var i = 0, nl = lower.length; i < nl; ++i) {\n        result[ptr++] = lower[i]\n    }\n    for (var j = upper.length - 2; j > 0; --j) {\n        result[ptr++] = upper[j]\n    }\n\n    let pList = [];\n    for( const i of result ) {\n        pList.unshift(points[i])\n    }\n\n    //Return result\n    return pList\n}\n\n// offset is + to the left, - to right (right won't work right now)\n// export function genArrayFromOutline(outline, offset, fillets, close, segments) {\n//     let outPoints = [];\n//     //todo turn fillets into array if it's just a value\n//     if (!segments) {\n//         segments = 4;\n//     }\n\n//     for (let i = 0; i < outline.length; i++) {\n//         let point = outline[i];\n//         let next = outline[(i + 1) % outline.length];\n//         let prev = outline[(i - 1 + outline.length) % outline.length];\n//         let nextDir = next.subtract(point).normalize();\n//         let prevDir = point.subtract(prev).normalize();\n//         let nextNorm = new BABYLON.Vector3(nextDir.z, 0, -nextDir.x);\n//         let prevNorm = new BABYLON.Vector3(prevDir.z, 0, -prevDir.x);\n//         let inPoint = point.add(prevNorm.scale(offset));\n//         let outPoint = point.add(nextNorm.scale(offset));\n\n//         let intersection = lineLineIntersection(inPoint, prevNorm,\n//             outPoint, nextNorm);\n//         if (intersection === null) {\n//             outPoints.push(inPoint);\n//             outPoints.push(outPoint);\n//             continue;\n//         }\n\n//         if (!fillets) {\n//             outPoints.push(intersection);\n//         }\n//         else {\n//             let fillet = fillets;\n//             let flip = BABYLON.Vector3.Dot(prevNorm,nextDir) > 0;\n//             if( flip ) {\n//                 fillet = -fillet;\n//             }\n//             let filletCenter = lineLineIntersection(inPoint.add(prevNorm.scale(-fillet)), prevNorm,\n//                 outPoint.add(nextNorm.scale(-fillet)), nextNorm);\n\n\n//             let startRot = getRotFromNormal(prevNorm)+ Math.PI * 2;\n//             let endRot = getRotFromNormal(nextNorm)+ Math.PI * 2;\n//             if(flip) {\n//                 startRot += Math.PI;\n//                 endRot += Math.PI;\n//                 fillet = -fillet;\n//                 if (startRot < endRot) {\n//                     startRot += Math.PI * 2;\n//                 }\n//             }\n//             else if (endRot < startRot) {\n//                 endRot += Math.PI * 2;\n//             }\n//             let rotStep = (endRot - startRot) / segments;\n//             for (let i = 0; i <= segments; i++) {\n//                 outPoints.push(filletCenter.add(getNormalFromRot(startRot + rotStep * i).scale(fillet)));\n//             }\n//         }\n//     }\n\n//     if (close) {\n//         outPoints.push(outPoints[0]);\n//     }\n\n//     return outPoints;\n// }\n\n\nfunction Point(point) {\n    this.type = 0;\n    this.point = point;\n}\n\n\nfunction Arc(center, radius, rotDegrees, endRot) {\n    this.type = 1;\n    this.center = center;\n    this.radius = radius;\n    this.rotDegrees = rotDegrees;\n    this.endRot = endRot;\n}\n\n// offset is + to the left, - to right (right won't work right now)\nexport function offsetAndFilletOutline(outline, offset, fillets, close) {\n    let vectorOutline = [];\n    //todo turn fillets into array if it's just a value\n    for (let i = 0; i < outline.length; i++) {\n        let point = outline[i];\n        let next = outline[(i + 1) % outline.length];\n        let prev = outline[(i - 1 + outline.length) % outline.length];\n        let nextDir = next.subtract(point).normalize();\n        let prevDir = point.subtract(prev).normalize();\n        let nextNorm = new BABYLON.Vector3(nextDir.z, 0, -nextDir.x);\n        let prevNorm = new BABYLON.Vector3(prevDir.z, 0, -prevDir.x);\n        let inPoint = point.add(prevNorm.scale(offset));\n        let outPoint = point.add(nextNorm.scale(offset));\n\n        let intersection = lineLineIntersection(inPoint, prevNorm,\n            outPoint, nextNorm);\n        if (intersection === null) {\n            vectorOutline.push(new Point(inPoint));\n            vectorOutline.push(new Point(outPoint));\n            continue;\n        }\n\n        if (!fillets) {\n            vectorOutline.push(new Point(intersection));\n        }\n        else {\n            let fillet = fillets;\n            let flip = BABYLON.Vector3.Dot(prevNorm,nextDir) > 0;\n            if( flip ) {\n                fillet = -fillet;\n            }\n            let filletCenter = lineLineIntersection(inPoint.add(prevNorm.scale(-fillet)), prevNorm,\n                                                    outPoint.add(nextNorm.scale(-fillet)), nextNorm);\n\n            vectorOutline.push(new Point(filletCenter.add(prevNorm.scale(fillet))));\n\n            let startRot = getRotFromNormal(prevNorm)+ Math.PI * 2;\n            let endRot = getRotFromNormal(nextNorm)+ Math.PI * 2;\n            if(flip) {\n                startRot += Math.PI;\n                endRot += Math.PI;\n                fillet = -fillet;\n                if (startRot < endRot) {\n                    startRot += Math.PI * 2;\n                }\n            }\n            else if (endRot < startRot) {\n                endRot += Math.PI * 2;\n            }\n            let totRot = endRot - startRot;\n            vectorOutline.push(new Arc(filletCenter, fillet, totRot, endRot))\n        }\n    }\n\n    if (close) {\n        vectorOutline.push(vectorOutline[0]);\n    }\n\n    return vectorOutline;\n}\n\nexport function genPointsFromVectorPath(vectorPath, segmentsPerFillet) {\n    let outPoints = [];\n    //todo turn fillets into array if it's just a value\n    if (!segmentsPerFillet) {\n        segmentsPerFillet = 4;\n    }\n\n    for (let i = 0; i < vectorPath.length; i++) {\n        let nextItem = vectorPath[i];\n        switch(nextItem.type) {\n            case 0:\n                outPoints.push(nextItem.point)\n                break;\n            case 1:\n                let rotStep = nextItem.rotDegrees / segmentsPerFillet;\n                let endRot = nextItem.endRot;\n                for (let i = segmentsPerFillet-1; i >= 0; i--) {\n                    outPoints.push(nextItem.center.add(getNormalFromRot(endRot - rotStep * i).scale(nextItem.radius)));\n                }\n                break;\n        }\n    }\n\n    return outPoints;\n}\n\nexport function genArrayFromOutline(outline, offset, fillets, close, segments) {\n    let vectorPath = offsetAndFilletOutline(outline, offset, fillets, close);\n    return genPointsFromVectorPath(vectorPath, segments);\n}","import {globals} from './globals.js'\nimport {tuning} from './tuning.js'\n\nexport function createKeyMaterial(name,color) {\n    let mats = globals.renderData.mats;\n    if(!mats[name])\n    {\n        mats[name] = new BABYLON.PBRMetallicRoughnessMaterial(name, globals.scene);\n        mats[name].metallic = 0;\n        mats[name].roughness = 0.6;\n        mats[name].baseColor = color;\n        mats[name].environmentTexture = globals.hdrTexture;\n    }\n}\n\nexport function createMaterials() {\n    let mats = globals.renderData.mats;\n    let name = \"keySel\";\n    if(!mats[name])\n    {\n        mats[name] = new BABYLON.StandardMaterial(name, globals.scene);\n        mats[name].diffuseColor = new BABYLON.Color3(0, 0, 0);\n        mats[name].emissiveColor = new BABYLON.Color3(1, 0, 0);\n        mats[name].specularColor = new BABYLON.Color3(0, 0, 0);\n    }\n\n    let caseMatName = \"case\";\n    if(!mats[caseMatName])\n    {\n        mats[caseMatName] = new BABYLON.PBRMetallicRoughnessMaterial(caseMatName, globals.scene);\n        mats[caseMatName].metallic = 0;\n        mats[caseMatName].roughness = 0.8;\n        mats[caseMatName].baseColor = new BABYLON.Color3(0.6, 0.6, 0.6);\n        mats[caseMatName].environmentTexture = globals.hdrTexture;\n    }\n\n    let plateMatName = \"plate\";\n    if(!mats[plateMatName])\n    {\n        mats[plateMatName] = new BABYLON.PBRMetallicRoughnessMaterial(plateMatName, globals.scene);\n        mats[plateMatName].metallic = 1;\n        mats[plateMatName].roughness = 0.2;\n        mats[plateMatName].baseColor = new BABYLON.Color3(0.5, 0.5, 0.5);\n        mats[plateMatName].environmentTexture = globals.hdrTexture;\n    }\n\n    let pcbMatName = \"fr4\";\n    if(!mats[pcbMatName])\n    {\n        mats[pcbMatName] = new BABYLON.PBRMetallicRoughnessMaterial(pcbMatName, globals.scene);\n        mats[pcbMatName].metallic = 0;\n        mats[pcbMatName].roughness = 0.2;\n        mats[pcbMatName].baseColor = new BABYLON.Color3(45/255, 90/255, 10/255);\n        mats[pcbMatName].environmentTexture = globals.hdrTexture;\n    }\n\n    createKeyMaterial(\"key\", new BABYLON.Color3(0.9, 0.9, 0.9));\n}\n\nexport function combineSideVerts(mesh) {\n    var _decPlaces = Math.pow(10, 8);\n    var _pdata = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n    var _ndata = mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n    var _idata = mesh.getIndices();    \n    var _newPdata = []; //new positions array\n    var _newIdata =[]; //new indices array\n    var _mapPtr =0; // new index;\n    var _uniquePositions = {}; // unique vertex positions\n    for(var _i=0; _i<_idata.length; _i+=3) {\n        var _facet = [_idata[_i], _idata[_i + 1], _idata[_i+2]]; //facet vertex indices\n        var _pstring = []; //lists facet vertex positions (x,y,z) as string \"xyz\"\"\n        for(var _j = 0; _j<3; _j++) { //\n            _pstring[_j] = \"\";\n            for(var _k = 0; _k<3; _k++) {\n                //small values make 0\n                if (Math.abs(_pdata[3*_facet[_j] + _k]) < 0.0001) {\n                    _pdata[3*_facet[_j] + _k] = 0;\n                }\n                _pstring[_j] += Math.round(_pdata[3*_facet[_j] + _k] * _decPlaces)/_decPlaces + \"|\";\n            }\n        }\n        //check facet vertices to see that none are repeated\n        // do not process any facet that has a repeated vertex, ie is a line\n        if(!(_pstring[0] == _pstring[1] || _pstring[0] == _pstring[2] || _pstring[1] == _pstring[2])) {        \n            //for each facet position check if already listed in uniquePositions\n            // if not listed add to uniquePositions and set index pointer\n            // if listed use its index in uniquePositions and new index pointer\n            for(var _j = 0; _j<3; _j++) { \n                var _ptr = _uniquePositions[_pstring[_j]];\n                if(_ptr === undefined) {\n                    _uniquePositions[_pstring[_j]] = _mapPtr;\n                    _ptr = _mapPtr++;\n                    //not listed so add individual x, y, z coordinates to new positions array newPdata\n                    //and add matching normal data to new normals array newNdata\n                    for(var _k = 0; _k<3; _k++) {\n                        _newPdata.push(_pdata[3*_facet[_j] + _k]);\n                    }\n                }\n                // add new index pointer to new indices array newIdata\n                _newIdata.push(_ptr);\n            }\n        }\n    }\n    let _newNdata =[]; //new normal data\n    BABYLON.VertexData.ComputeNormals(_newPdata, _newIdata, _newNdata);\n    //create new vertex data object and update\n    var _vertexData = new BABYLON.VertexData();\n    _vertexData.positions = _newPdata;\n    _vertexData.indices = _newIdata;\n    _vertexData.normals = _newNdata;\n    _vertexData.applyToMesh(mesh);\n}\n\nexport function snapCamera() {\n    const bd = globals.boardData;\n    globals.camera.setTarget(new BABYLON.Vector3(bd.layout.bounds.mins[0] + (bd.layout.bounds.maxs[0] - bd.layout.bounds.mins[0]) / 2.0,\n        0,\n        bd.layout.bounds.mins[1] + (bd.layout.bounds.maxs[1] - bd.layout.bounds.mins[1]) / 2.0));\n    globals.camera.alpha = -Math.PI / 2;\n    globals.camera.beta = 0;\n    globals.camera.radius = 600;\n}\n\nfunction createScene() {\n    const engine = globals.engine;\n\n    // create a basic BJS Scene object\n    var scene = new BABYLON.Scene(engine);\n\n    var camera = new BABYLON.ArcRotateCamera(\"Camera\", -Math.PI / 2, 0, 10, new BABYLON.Vector3(0, 0, 0), scene);\n\n    // target the camera to scene origin\n    camera.setTarget(BABYLON.Vector3.Zero());\n\n    camera.fov = 0.3;\n    camera.lowerRadiusLimit = 75;\n    camera.upperRadiusLimit = 1500;\n\n    // attach the camera to the canvas\n    camera.attachControl(globals.canvas, false);\n\n    globals.camera = camera;\n\n    var ssao = new BABYLON.SSAORenderingPipeline('ssaopipeline', scene, 0.75, [camera]);\n    ssao.base = 0.6;\n    ssao.radius = 0.001;\n    ssao.area = 0.003;\n    ssao.falloff = 0.00001;\n\n    // create a basic light, aiming 0,1,0 - meaning, to the sky\n    // var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);\n    // // Default intensity is 1. Let's dim the light a small amount\n    // light.intensity = 0.7;\n    var skyboxPath = \"assets/studio_small.env\";\n    globals.hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(skyboxPath, scene);\n    globals.currentSkybox = scene.createDefaultSkybox(globals.hdrTexture, true, (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2, 0.3);\n\n    // return the created scene\n    return scene;\n}\n\nexport function init() {\n    // get the canvas DOM element\n    globals.canvas = document.getElementById('renderCanvas');\n\n    // load the 3D engine\n    globals.engine = new BABYLON.Engine(globals.canvas, true);\n\n    // call the createScene function\n    globals.scene = createScene();\n}\n","import {globals} from './globals.js'\nimport {tuning} from './tuning.js'\nimport * as coremath from './coremath.js'\nimport * as gfx from './gfx.js'\n\nexport function refreshOutlines() {\n    let kRD = globals.renderData.keys;\n    let oRD = globals.renderData.outlines;\n    let mats = globals.renderData.mats;\n\n    for (const [k, o] of Object.entries(oRD)) {\n        globals.scene.removeMesh(o);\n    }\n\n    for (const id of globals.pickedKeys) {\n        if (!kRD[id]) {\n            console.log(\"picked nonexistant key\");\n        }\n        else {\n            let rd = kRD[id];\n\n            oRD[id] = BABYLON.MeshBuilder.CreateRibbon(id + \"outline\",\n                {\n                    pathArray: [coremath.genArrayFromOutline(rd.outline, 0.1, 0.1, true),\n                        coremath.genArrayFromOutline(rd.outline, 0.5, 0.5, true)]\n                }, globals.scene);\n            oRD[id].material = mats[\"keySel\"];\n            oRD[id].translate(new BABYLON.Vector3(0, 10.5, 0), 1, BABYLON.Space.LOCAL);\n        }\n    }\n}\n\nfunction getPlateCutsWithStabs(width,height,kXform,plateCuts,pcbBounds) {\n    let switchCutDims = [tuning.switchCutout[0]*0.5, tuning.switchCutout[1]*0.5];\n    let sXform = kXform;\n\n    // wack ass cherry 6u spacebar\n    if(width == 6) {\n        sXform = BABYLON.Matrix.Translation(9.525, 0, 0).multiply(sXform)\n    }\n    plateCuts.push([\n        BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-switchCutDims[0], 0, -switchCutDims[1]), sXform),\n        BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(switchCutDims[0], 0, -switchCutDims[1]), sXform),\n        BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(switchCutDims[0], 0, switchCutDims[1]), sXform),\n        BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-switchCutDims[0], 0, switchCutDims[1]), sXform)\n    ]);\n\n    // pcb footprint of a hotswap switch: x +/- 9 y +/- 6.75\n    // enc: 6.75, 8,5\n    let keyPCBBounds = [9,6.75];\n    pcbBounds.push([\n        BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-keyPCBBounds[0], 0, -keyPCBBounds[1]), sXform),\n        BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(keyPCBBounds[0], 0, -keyPCBBounds[1]), sXform),\n        BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(keyPCBBounds[0], 0, keyPCBBounds[1]), sXform),\n        BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-keyPCBBounds[0], 0, keyPCBBounds[1]), sXform)\n    ]);\n\n    let span = width;\n    if(height >= 1.75) {\n        span = height;\n        sXform = BABYLON.Matrix.RotationY(Math.PI / 2.0).multiply(sXform);\n    }\n\n    let stabCutDims = [7*0.5,15*0.5];\n    if( span >= 2 ) {\n        let stabOffsetXL = 0.0;\n        let stabOffsetXR = 0.0;\n        if(span <= 2.75) {\n            stabOffsetXL = stabOffsetXR = 11.938;\n        }\n        else if(span <= 3.0) {\n            stabOffsetXL = stabOffsetXR = 19.05;\n        }\n        else if(span <= 4) {\n            stabOffsetXL = stabOffsetXR = 28.575;\n        }\n        else if(span <= 4.5) {\n            stabOffsetXL = stabOffsetXR = 34.671;\n        }\n        else if(span <= 5.5) {\n            stabOffsetXL = stabOffsetXR = 42.8625;\n        }\n        else if(span == 6) {\n            // cherry 6u again\n            stabOffsetXL = 57.15;\n            stabOffsetXR = 38.1\n        }\n        else if(span <= 6) {\n            stabOffsetXL = stabOffsetXR = 47.5;\n        }\n        else if(span <= 6.25) {\n            stabOffsetXL = stabOffsetXR = 50;\n        }\n        else if(span <= 6.5) {\n            stabOffsetXL = stabOffsetXR = 52.38;\n        }\n        else if(span <= 7) {\n            stabOffsetXL = stabOffsetXR = 57.15;\n        }\n        else {\n            stabOffsetXL = stabOffsetXR = 66.675;\n        }\n\n        let stabXforms = [BABYLON.Matrix.Translation(-stabOffsetXL, 0, -2).multiply(sXform),\n                          BABYLON.Matrix.Translation( stabOffsetXR, 0, -2).multiply(sXform)];\n        let stabCut = [new BABYLON.Vector3(-stabCutDims[0], 0, -stabCutDims[1]),\n                       new BABYLON.Vector3(stabCutDims[0], 0, -stabCutDims[1]),\n                       new BABYLON.Vector3(stabCutDims[0], 0, stabCutDims[1]),\n                       new BABYLON.Vector3(-stabCutDims[0], 0, stabCutDims[1])];\n\n        // stab foot = 4 wide x 19 h\n        let stabPCBFootDims = [3,9.5];\n        let stabFoot = [new BABYLON.Vector3(-stabPCBFootDims[0], 0, -7),\n        new BABYLON.Vector3(stabPCBFootDims[0], 0, -7),\n        new BABYLON.Vector3(stabPCBFootDims[0], 0, 11),\n        new BABYLON.Vector3(-stabPCBFootDims[0], 0, 11)];\n\n        for(let j = 0; j < stabXforms.length; j++) {\n            let xformedCut = [];\n            for(let i = 0; i < stabCut.length; i++) {\n                xformedCut.push(BABYLON.Vector3.TransformCoordinates(stabCut[i],stabXforms[j]));\n            }\n            plateCuts.push(xformedCut);\n\n            let xformedPCBBounds = [];\n            for(let i = 0; i < stabFoot.length; i++) {\n                xformedPCBBounds.push(BABYLON.Vector3.TransformCoordinates(stabFoot[i],stabXforms[j]));\n            }\n            pcbBounds.push(xformedPCBBounds);\n        }\n    }\n}\n\nexport function refreshLayout() {\n    const scene = globals.scene;\n    const bd = globals.boardData;\n\n    let mins = [100000.0, 100000.0]\n    let maxs = [-100000.0, -100000.0];\n\n    let bezelHoles = [];\n\n    let kRD = globals.renderData.keys;\n    // clear the renderdata (cache this later?)\n    for(const [id, rd] of Object.entries(kRD)) {\n        if (rd.keycap) {\n            scene.removeMesh(rd.keycap);\n        }\n    }\n    kRD = globals.renderData.keys = [];\n    \n    let outlines = [];\n\n    let kgID = 0;\n    for (const [id, k] of Object.entries(bd.layout.keys)) {\n        // console.log(k);\n\n        if (!kRD[id]) {\n            kRD[id] = {keyGroupId:null,id:id,\n                        mins:[100000.0, 100000.0], maxs:[-100000.0, -100000.0],\n                        bezelMins:[100000.0, 100000.0], bezelMaxs:[-100000.0, -100000.0],\n                        overlappingKeys:{}\n                    };\n        }\n        let rd = kRD[id];\n\n        let keycapDim = [(tuning.keyDims[0] + tuning.base1U[0] * (k.width - 1)) / 2,\n        (tuning.keyDims[1] + tuning.base1U[1] * (k.height - 1)) / 2];\n\n        // let uDim = [(tuning.base1U[0] + tuning.base1U[0] * (k.width - 1)) / 2,\n        // (tuning.base1U[1] + tuning.base1U[1] * (k.height - 1)) / 2];\n\n        let kPos = [k.x * tuning.base1U[0] + keycapDim[0],\n        -(k.y * tuning.base1U[1] + keycapDim[1])]\n        let kPosition = new BABYLON.Vector3(kPos[0], 0, kPos[1]);\n        let kXform = BABYLON.Matrix.Identity();\n        kXform = kXform.multiply(BABYLON.Matrix.Translation(kPos[0], 0, kPos[1]));\n        if (k.rotation_angle != 0) {\n            kXform = kXform.multiply(BABYLON.Matrix.Translation(-k.rotation_x * tuning.base1U[0], 0, k.rotation_y * tuning.base1U[1]));\n            kXform = kXform.multiply(BABYLON.Matrix.RotationY(k.rotation_angle * Math.PI / 180.0))\n            kXform = kXform.multiply(BABYLON.Matrix.Translation(k.rotation_x * tuning.base1U[0], 0, -k.rotation_y * tuning.base1U[1]));\n        }\n        rd.outline = [\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-keycapDim[0], 0, -keycapDim[1]), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(keycapDim[0], 0, -keycapDim[1]), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(keycapDim[0], 0, keycapDim[1]), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-keycapDim[0], 0, keycapDim[1]), kXform)\n        ];\n\n        rd.pcbBoxes = [];\n        rd.switchCut = [];\n\n        getPlateCutsWithStabs(k.width,k.height,kXform,rd.switchCut,rd.pcbBoxes);\n\n        if (rd.keycap) {\n            scene.removeMesh(rd.keycap);\n        }\n        if (tuning.keyShape) {\n            rd.keycap = BABYLON.MeshBuilder.CreatePolygon(id, { shape: rd.outline, depth: 7, updatable: false }, scene);\n            rd.keycap.translate(new BABYLON.Vector3(0, 10.5, 0), 1, BABYLON.Space.LOCAL);\n    \n            if(k.matName && globals.renderData.mats[k.matName]) {\n                rd.keycap.material = globals.renderData.mats[k.matName];\n            }\n        }\n\n        rd.bezelHole = [\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-keycapDim[0] - tuning.bezelGap, 0, -keycapDim[1] - tuning.bezelGap), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(keycapDim[0] + tuning.bezelGap, 0, -keycapDim[1] - tuning.bezelGap), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(keycapDim[0] + tuning.bezelGap, 0, keycapDim[1] + tuning.bezelGap), kXform),\n            BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(-keycapDim[0] - tuning.bezelGap, 0, keycapDim[1] + tuning.bezelGap), kXform)\n        ];\n        bezelHoles.push(rd.bezelHole);\n\n        for (let p of rd.bezelHole) {\n            rd.bezelMins[0] = Math.min(rd.bezelMins[0], p.x);\n            rd.bezelMaxs[0] = Math.max(rd.bezelMaxs[0], p.x);\n            rd.bezelMins[1] = Math.min(rd.bezelMins[1], p.z);\n            rd.bezelMaxs[1] = Math.max(rd.bezelMaxs[1], p.z);\n        }\n\n        for (let p of rd.outline) {\n            rd.mins[0] = Math.min(rd.mins[0], p.x);\n            rd.maxs[0] = Math.max(rd.maxs[0], p.x);\n            rd.mins[1] = Math.min(rd.mins[1], p.z);\n            rd.maxs[1] = Math.max(rd.maxs[1], p.z);\n        }\n        mins[0] = Math.min(rd.mins[0], mins[0]);\n        maxs[0] = Math.max(rd.maxs[0], maxs[0]);\n        mins[1] = Math.min(rd.mins[1], mins[1]);\n        maxs[1] = Math.max(rd.maxs[1], maxs[1]);\n\n        let checkOverlap = function(k1, rd1, k2, rd2) {\n            if( rd1.bezelMins[0]+BABYLON.Epsilon > rd2.bezelMaxs[0] || rd2.bezelMins[0]+BABYLON.Epsilon > rd1.bezelMaxs[0] ||\n                rd1.bezelMins[1]+BABYLON.Epsilon > rd2.bezelMaxs[1] || rd2.bezelMins[1]+BABYLON.Epsilon > rd1.bezelMaxs[1] ) {\n                return false\n            }\n\n            // see if any of the lines bisect the other rect  (since it's a rect, we know each line is actually a normal of the previous)\n\n            let checkIntersection = (pRD, oRD) => {\n                for(let iP = 0; iP < pRD.bezelHole.length; iP++) {\n                    let line = pRD.bezelHole[(iP+1)%pRD.bezelHole.length].subtract(pRD.bezelHole[iP]);\n                    let allLess = true;\n                    let allMore = true;\n                    for(let oP = 0; oP < oRD.bezelHole.length; oP++) {\n                        let dot = BABYLON.Vector3.Dot(line,oRD.bezelHole[oP].subtract(pRD.bezelHole[iP]));\n                        allMore &= dot > -BABYLON.Epsilon;\n                        allLess &= dot < BABYLON.Epsilon;\n                    }\n    \n                    if( allMore || allLess ) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            let confirmedIntersection = checkIntersection(rd1,rd2);\n            if(!confirmedIntersection) {\n                confirmedIntersection = checkIntersection(rd2,rd1);\n            }\n\n            if(confirmedIntersection) {\n                rd1.overlappingKeys[rd2.id] = rd2;\n                rd2.overlappingKeys[rd1.id] = rd1;\n                if(rd1.keyGroupId && rd2.keyGroupId) {\n                    // merge\n                    // console.log(`merging kgIDs ${rd1.keyGroupId} and ${rd2.keyGroupId}`);\n                    let pKG = rd1.keyGroupId;\n                    let oKG = rd2.keyGroupId;\n                    for(const [otherId, oRD] of Object.entries(kRD)) {\n                        if(oRD.keyGroupId == oKG) {\n                            oRD.keyGroupId = pKG;\n                        }\n                    }\n                }\n                else if(rd1.keyGroupId) {\n                    rd2.keyGroupId = rd1.keyGroupId;\n                }\n                else if(rd2.keyGroupId) {\n                    rd1.keyGroupId = rd2.keyGroupId;\n                }\n                else {\n                    rd1.keyGroupId = rd2.keyGroupId = kgID++;\n                }\n            }\n        }\n\n        for (const [otherId, otherRD] of Object.entries(kRD)) {\n            if(otherId == id) {\n                continue;\n            }\n\n            let otherKey = bd.layout.keys[otherId];\n            checkOverlap(k,rd,otherKey,otherRD);\n        }\n\n        if(!rd.keyGroupId) {\n            rd.keyGroupId = kgID++;\n        }\n    }\n\n    bd.layout.bounds = { mins: mins, maxs: maxs };\n\n    let kPs = [];\n    for( let [id,rd] of Object.entries(kRD) ) {\n        for( let b of rd.pcbBoxes) {\n            for( let p of b) {\n                kPs.push(p)\n            }\n        }\n    }\n    bd.pcbOutline = coremath.convexHull2d(kPs);\n    if(bd.forcePCBSymmetrical) {\n        let midPoint = (bd.layout.bounds.maxs[0] - bd.layout.bounds.mins[0]) * 0.5 + bd.layout.bounds.mins[0];\n        for(let oP of bd.pcbOutline) {\n            kPs.push(new BABYLON.Vector3(midPoint - (oP.x - midPoint), oP.y, oP.z));\n        }\n        bd.pcbOutline = coremath.convexHull2d(kPs);\n    }\n    bd.pcbBounds = {mins:[100000.0, 100000.0],\n                     maxs:[-100000.0, -100000.0]};\n    for(let p of bd.pcbOutline) {\n        bd.pcbBounds.mins[0] = Math.min(bd.pcbBounds.mins[0], p.x);\n        bd.pcbBounds.maxs[0] = Math.max(bd.pcbBounds.maxs[0], p.x);\n        bd.pcbBounds.mins[1] = Math.min(bd.pcbBounds.mins[1], p.z);\n        bd.pcbBounds.maxs[1] = Math.max(bd.pcbBounds.maxs[1], p.z);\n    }\n\n\n    refreshOutlines();\n}\n\nfunction getCombinedOutlineFromRDGroup(KG) {\n    for( const rd of KG ) {\n        rd.outlineLines = [];\n        rd.parsedOutlineLines = {};\n        for(let p = 0; p < rd.bezelHole.length; p++) {\n            let lStart = rd.bezelHole[p];\n            let lEnd = rd.bezelHole[(p+1)%rd.bezelHole.length]\n            rd.outlineLines.push([lStart,lEnd]);\n        }\n    }\n\n\n    let maxOverlapSq = BABYLON.Epsilon;\n\n    let overlapFunc = (primeL, primeLen, otherLen, line, norm, distBetween, lineArray, parseArray) => {\n        if(!parseArray[primeL]) {\n            let primeToOtherNear = Math.max(distBetween - otherLen,0) / primeLen;\n            let primeToOtherFar = distBetween / primeLen;\n            if(primeToOtherNear < 1 - BABYLON.Epsilon && primeToOtherFar > BABYLON.Epsilon) {\n                // kill O and replace it with any remaining line segments\n                //parseArray[primeL] = true;\n                if (primeToOtherNear > BABYLON.Epsilon) {\n                    lineArray.push([line[0],line[0].add(norm.scale(distBetween - otherLen))]);\n                }\n                if (primeToOtherFar < 1 - BABYLON.Epsilon) {\n                    lineArray.push([line[0].add(norm.scale(distBetween)), line[1]]);\n                }\n                lineArray.splice(primeL,1);\n            }\n        }\n    }\n    // clip any overlapping parallel lines against each other (cancel if they face each other)\n    for( const rd of KG ) {\n        // if(true) break;\n        rd.visitedForOutline = true;\n\n        for( const [oId,otherRD] of Object.entries(rd.overlappingKeys) ) {\n            //if(otherRD.visitedForOutline) continue;\n            for(let iL = rd.outlineLines.length-1; iL >= 0; iL--) {\n                let lL = rd.outlineLines[iL];\n                let lDir = lL[1].subtract(lL[0]);\n                let lLen = lDir.length()\n                if(lLen < BABYLON.Epsilon) continue;\n                let lineNorm = lDir.normalizeFromLength(lLen);\n\n                for( let jL = otherRD.outlineLines.length-1; jL > 0; jL-- ) {\n                    let oL = otherRD.outlineLines[jL];\n                    let oDir = oL[1].subtract(oL[0]);\n                    let oLen = oDir.length();\n                    if(oLen < BABYLON.Epsilon ) continue;\n                    let oLNorm = oDir.normalizeFromLength(oLen);\n                    let lineDot = BABYLON.Vector3.Dot(oLNorm,lineNorm)\n                    if( Math.abs(lineDot) > 1-BABYLON.Epsilon) {\n                        let diff = lL[0].subtract(oL[0]);\n                        if(diff.lengthSquared() < BABYLON.Epsilon) {\n                            let d2 = lL[1].subtract(oL[1]);\n                            let d2ls = d2.lengthSquared();\n                            if(d2ls< BABYLON.Epsilon || d2ls > lLen*lLen) {\n                                rd.outlineLines.splice(iL,1);\n                                break;\n                            } else {\n                                lL[0] = oL[1];\n                                break;\n                            }\n                        }\n                        let dd = BABYLON.Vector3.Dot(diff, oLNorm);\n                        let projPoint = oL[0].add(oLNorm.scale(dd))\n                        if( projPoint.subtract(lL[0]).lengthSquared() < maxOverlapSq) {\n                            // check to see if these two are facing away from each other\n                            if(lineDot < BABYLON.Epsilon-1) {\n                                // at this point, dd is the distance between the two starting points (which are facing each other) \n                                // erase the overlapping portion of each line\n                                // O ------------> olen\n                                //      llen <--------- L\n                                // O <----------------> dd\n                                overlapFunc(jL,oLen,lLen,oL,oLNorm,dd,otherRD.outlineLines,otherRD.parsedOutlineLines);\n                                overlapFunc(iL,lLen,oLen,lL,lineNorm,dd,rd.outlineLines,rd.parsedOutlineLines);\n                            }\n                            else if( lineDot > 1-BABYLON.Epsilon ) {\n                                if( dd > BABYLON.Epsilon ) {\n                                    // O -------->\n                                    //        L ---------->\n                                    // O <---> dd\n                                    // consume L\n                                    let overlapDist = oLen - dd;\n                                    if(!rd.parsedOutlineLines[iL]) {\n                                        if(overlapDist > BABYLON.Epsilon) {\n                                            // console.log(`trimming A ${rd.id} ${iL} vs ${oId} ${jL} len ${lLen} ov ${overlapDist}`)\n                                            if(lLen - overlapDist < BABYLON.Epsilon)\n                                            {\n                                                // console.log(`SPLICE`);\n                                                rd.outlineLines.splice(iL,1);\n                                                break;\n                                            }\n                                            // rd.parsedOutlineLines[iL] = true;\n                                            // rd.outlineLines.push([lL[0].add(lineNorm.scale(overlapDist)),lL[1]]);\n                                            lL[0] = lL[0].add(lineNorm.scale(overlapDist));\n                                        }\n                                    }\n                                }\n                                if( dd < BABYLON.Epsilon ) {\n                                    // L -------->\n                                    //        O ---------->\n                                    // L <---> -dd\n                                    // consume L\n                                    let d = -dd;\n                                    if(!rd.parsedOutlineLines[iL]) {\n                                        if(d < lLen - BABYLON.Epsilon) {\n                                            // console.log(`trimming B ${rd.id} ${iL} vs ${oId} ${jL} d ${d}`)\n                                            if(d < BABYLON.Epsilon)\n                                            {\n                                                // console.log(`SPLICE`);\n                                                rd.outlineLines.splice(iL,1);\n                                                break;\n                                            }\n                                            // rd.parsedOutlineLines[iL] = true;\n                                            // rd.outlineLines.push([lL[0],lL[0].add(lineNorm.scale(d))]);\n                                            lL[1] = lL[0].add(lineNorm.scale(d));\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    for( const rd of KG ) {\n        // if(true) break;\n        for( const [oId,otherRD] of Object.entries(rd.overlappingKeys) ) {\n            for(let iL = rd.outlineLines.length - 1; iL >= 0; iL--) {\n                let l = rd.outlineLines[iL];\n                let lL = l[1].subtract(l[0]);\n                let lNorm = new BABYLON.Vector3(lL.z,0,-lL.x).normalize();\n\n                let intersections = [];\n                let colinear = false;\n                for(let iOP = 0; iOP < otherRD.bezelHole.length; iOP++) {\n                    let segRes = coremath.segmentToSegment(l[0], l[1], lL, lNorm, otherRD.bezelHole[iOP], otherRD.bezelHole[(iOP+1)%otherRD.bezelHole.length]);\n                    if(segRes.type == \"in_segment\" && segRes.intersection) {\n                        // console.log(`intersecting ${rd.id} line ${iL} with ${otherRD.id} line ${iOP}` )\n                        // console.log(l)\n                        intersections.push(segRes.intersection);\n                    }\n                    else if(segRes.type == \"colinear\") {\n                        // console.log(`bailing colinear ${rd.id} line ${iL} with ${otherRD.id} line ${iOP}`);\n                        // we're colinear with an edge, so we don't have anything to clip with this box\n                        colinear = true;\n                        break;\n                    }\n                }\n                if(colinear) continue;\n\n                let isStartInPoly = coremath.isPointInPoly(l[0],otherRD.bezelHole);\n                let isEndInPoly = coremath.isPointInPoly(l[1],otherRD.bezelHole);\n\n                // console.log(`${rd.id} line ${iL} with ${otherRD.id} startIn ${isStartInPoly} end ${isEndInPoly} ${intersections.length}`);\n                if(isStartInPoly && isEndInPoly && intersections.length <= 1) {\n                    // both are inside the poly, just remove the line\n                    // console.log(`removing line ${iL} from ${rd.id}`);\n                    rd.outlineLines.splice(iL, 1);\n                }\n                else if(intersections.length == 1) {\n                    // console.log(`splitting (one intersection) line ${iL} from ${rd.id}`);\n                    // console.log(`start ${isStartInPoly} end ${isEndInPoly}`);\n                    if(isStartInPoly) {\n                        l[0] = intersections[0];\n                    } else {\n                        l[1] = intersections[0];\n                    }\n                    if(l[1].subtract(l[0]).lengthSquared() < BABYLON.Epsilon) {\n                        rd.outlineLines.splice(iL, 1);\n                    }\n                }\n                else if(intersections.length > 1) {\n                    // console.log(`multisplit line ${iL} from ${rd.id}`);\n                    // console.log(`${rd.id} l is ${l[0]} ${l[1]}`);\n                    intersections.sort((a,b) => (a.subtract(l[0]).lengthSquared() - b.subtract(l[0]).lengthSquared()))\n                    let tmp = l[1];\n                    l[1] = intersections[0];\n                    if(l[1].subtract(l[0]).lengthSquared() < BABYLON.Epsilon) {\n                        // console.log(\"skipping start length due to shortness\");\n                        rd.outlineLines.splice(iL, 1);\n                    }\n                    // console.log(`${rd.id} start is ${l[0]} ${l[1]}`);\n                    for(let i = 2; i < intersections.length; i+=2) {\n                        if( intersections[i-1].subtract(intersections[i]).lengthSquared() > BABYLON.Epsilon) {\n                            rd.outlineLines.push([intersections[i-1],intersections[i]]);\n                        } \n                        // console.log(`${rd.id} mid is ${intersections[i-1]} ${intersections[i]}`);\n                    }\n                    if(intersections.length % 2 == 0) {\n                        if( intersections[intersections.length-1].subtract(tmp).lengthSquared() > BABYLON.Epsilon) {\n                            rd.outlineLines.push([intersections[intersections.length-1],tmp]);\n                            // console.log(`${rd.id} end is ${intersections[intersections.length-1]} ${tmp}`);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    let parsedLines = [];\n    let nextKeyRd = null;\n    let nextLineIndex = -1;\n    let invertNextLine = false;\n    // pick a line at random.  this could actually pick something on an interior island so we should probably\n    // run the loop gen algorithm until all the lines are used up and then pick the polygon with the largest area\n    for( const rd of KG ) {\n        for(let iL = 0; iL < rd.outlineLines.length; iL++) {\n            if(!rd.parsedOutlineLines[iL]) {\n                nextKeyRd = rd;\n                nextLineIndex = iL;\n                break;\n            }\n        }\n        if(nextLineIndex >= 0) break;\n    }\n    \n    let outline = [];\n    // finally, walk through the list of available outline lines and pick the closest end point for the next line\n    while(nextKeyRd != null && nextLineIndex >= 0) {\n        nextKeyRd.parsedOutlineLines[nextLineIndex] = true;\n        let prevLine = nextKeyRd.outlineLines[nextLineIndex];\n        if(invertNextLine) {\n            let tmp = prevLine[0];\n            prevLine[0] = prevLine[1];\n            prevLine[1] = tmp;\n        }\n        // console.log(`key rd ${nextKeyRd.id} line idx ${nextLineIndex} s ${prevLine[0]} e ${prevLine[1]}`)\n        \n        outline.push(prevLine[0]);\n\n        parsedLines.push(prevLine);\n        nextLineIndex = -1;\n        let nextDistSq = 20.0\n\n        let checkNext = (n,nRd,i) => {\n            let newDistSq = prevLine[1].subtract(n[0]).lengthSquared();\n            if(newDistSq < nextDistSq) {\n                nextDistSq = newDistSq;\n                nextKeyRd = nRd;\n                nextLineIndex = i;\n                invertNextLine = false;\n            }\n\n            newDistSq = prevLine[1].subtract(n[1]).lengthSquared();\n            if(newDistSq < nextDistSq) {\n                nextDistSq = newDistSq;\n                nextKeyRd = nRd;\n                nextLineIndex = i;\n                invertNextLine = true;\n            }\n        }\n        \n        for(let iL = 0; iL < nextKeyRd.outlineLines.length; iL++) {\n            if(!nextKeyRd.parsedOutlineLines[iL]) {\n                checkNext(nextKeyRd.outlineLines[iL],nextKeyRd,iL);\n            }\n        }\n\n        for( const [oId,otherRD] of Object.entries(nextKeyRd.overlappingKeys) ) {\n            for( let jL = 0; jL < otherRD.outlineLines.length; jL++ ) {\n                if(otherRD.parsedOutlineLines[jL]) continue;\n\n                checkNext(otherRD.outlineLines[jL],otherRD,jL);\n            }\n        }\n    }\n    return outline;\n}\n\n\nexport function refreshCase() {\n    const scene = globals.scene;\n    const bd = globals.boardData;\n    const kRD = globals.renderData.keys;\n    const mats = globals.renderData.mats;\n\n    if(bd.caseType == \"convex\") {\n        let kPs = [];\n        for( let [id,rd] of Object.entries(kRD) ) {\n            for( let p of rd.outline ) {\n                kPs.push(p)\n            }\n        }\n        for(let p of bd.pcbOutline) {\n            kPs.push(p);\n        }\n        bd.outline = coremath.convexHull2d(kPs);\n\n        if(bd.forceSymmetrical) {\n            let midPoint = (bd.layout.bounds.maxs[0] - bd.layout.bounds.mins[0]) * 0.5 + bd.layout.bounds.mins[0];\n            for(let oP of bd.outline) {\n                kPs.push(new BABYLON.Vector3(midPoint - (oP.x - midPoint), oP.y, oP.z));\n            }\n            bd.outline = coremath.convexHull2d(kPs);\n        }\n    }\n    else\n    {\n        let pcbBounds = bd.pcbBounds;\n        let bounds = bd.layout.bounds;\n        bd.outline = [\n            new BABYLON.Vector3(Math.min(bounds.mins[0],pcbBounds.mins[0]), 0, Math.min(bounds.mins[1],pcbBounds.mins[1])),\n            new BABYLON.Vector3(Math.max(bounds.maxs[0],pcbBounds.maxs[0]), 0, Math.min(bounds.mins[1],pcbBounds.mins[1])),\n            new BABYLON.Vector3(Math.max(bounds.maxs[0],pcbBounds.maxs[0]), 0, Math.max(bounds.maxs[1],pcbBounds.maxs[1])),\n            new BABYLON.Vector3(Math.min(bounds.mins[0],pcbBounds.mins[0]), 0, Math.max(bounds.maxs[1],pcbBounds.maxs[1]))\n        ];\n    }\n\n    let cRD = globals.renderData.case;\n    cRD.layers = {};\n\n\n    let cavityInnerEdgeVec = [coremath.offsetAndFilletOutline(bd.outline, tuning.bezelGap, tuning.bezelCornerFillet, false)];\n    // let cavityInnerEdge = [coremath.genArrayFromOutline(bd.outline, tuning.bezelGap, tuning.bezelCornerFillet, false)];\n    let caseFrameVec = coremath.offsetAndFilletOutline(bd.outline, tuning.bezelGap + tuning.bezelThickness, tuning.caseCornerFillet, false);\n    let caseFrame = coremath.genPointsFromVectorPath(caseFrameVec,8);\n\n    if (cRD.edgeMesh) {\n        scene.removeMesh(cRD.edgeMesh);\n    }\n    if( tuning.drawCase ) {\n        cRD.layers[\"edge\"] = {outlines:[caseFrameVec, ...cavityInnerEdgeVec]};\n        cRD.edgeMesh = BABYLON.MeshBuilder.CreatePolygon(\"edge\", \n                                                         { shape: caseFrame, depth:9, \n                                                           holes: cavityInnerEdgeVec.map((a) => coremath.genPointsFromVectorPath(a,8)),\n                                                           updatable: true }, scene);\n        cRD.edgeMesh.translate(new BABYLON.Vector3(0, -1.5, 0), 1, BABYLON.Space.LOCAL);\n        cRD.edgeMesh.material = mats[\"case\"];\n        //gfx.combineSideVerts(cRD.edgeMesh);\n    }\n\n    if (cRD.bottom) {\n        scene.removeMesh(cRD.bottom);\n    }\n    if( tuning.drawCase ) {\n        cRD.layers[\"bottom\"] = {outlines:[caseFrameVec]};\n        cRD.bottom = BABYLON.MeshBuilder.CreatePolygon(\"bottom\", { shape: caseFrame, depth:3, updatable: true }, scene);\n        cRD.bottom.translate(new BABYLON.Vector3(0, -9-1.5, 0), 1, BABYLON.Space.LOCAL);\n        cRD.bottom.material = mats[\"case\"];\n    }\n\n    if (cRD.pcbMesh) {\n        scene.removeMesh(cRD.pcbMesh);\n    }\n    if( tuning.drawPCB ) {\n        let pcbOutlineVec = coremath.offsetAndFilletOutline(bd.pcbOutline, 0.0, 2.0, false);\n        let pcbOutline = coremath.genPointsFromVectorPath(pcbOutlineVec);\n        cRD.layers[\"pcb\"] = {outlines:[pcbOutlineVec]};\n        cRD.pcbMesh = BABYLON.MeshBuilder.CreatePolygon(\"pcbMesh\", { shape: pcbOutline, depth:1.6, updatable: true }, scene);\n        cRD.pcbMesh.translate(new BABYLON.Vector3(0, -5.0, 0), 1, BABYLON.Space.LOCAL);\n        cRD.pcbMesh.material = mats[\"fr4\"];\n    }\n\n    let keyGroups = {};\n    let bezelOutlineVecs = []\n    let bezelOutlines = [];\n    for(const [otherId, oRD] of Object.entries(kRD)) {\n        // console.log(`${otherId} is in kgid: ${oRD.keyGroupId}`);\n        if(!keyGroups[oRD.keyGroupId]) {\n            keyGroups[oRD.keyGroupId] = [];\n        }\n        keyGroups[oRD.keyGroupId].push(oRD);\n    }\n\n    let dbglines = [];\n    for(const [kgId, KG] of Object.entries(keyGroups)) {\n        let outline = getCombinedOutlineFromRDGroup(KG);\n\n        let bezelOutlineVec = coremath.offsetAndFilletOutline(outline, 0.0, tuning.bezelCornerFillet, false);\n        bezelOutlineVecs.push(bezelOutlineVec);\n        bezelOutlines.push(coremath.genPointsFromVectorPath(bezelOutlineVec));\n        \n        // for( const rd of KG ) {\n        //     for(let iL = 0; iL < rd.outlineLines.length; iL++) {\n        //         dbglines.push(rd.outlineLines[iL])\n        //     }\n        // }\n    }\n    // if( globals.lineSystem ) {\n    //     globals.scene.removeMesh(globals.lineSystem)\n    // }\n    // globals.lineSystem = BABYLON.MeshBuilder.CreateLineSystem(\"lineSystem\", {lines: dbglines}, globals.scene);\n    \n    if (cRD.bezel) {\n        scene.removeMesh(cRD.bezel);\n    }\n    if( tuning.drawBezel ) {\n\n        cRD.layers[\"bezel\"] = {outlines:[caseFrameVec, ...bezelOutlineVecs]};\n        cRD.bezel = BABYLON.MeshBuilder.CreatePolygon(\"bezel\", { shape: caseFrame, depth:7.5, holes: bezelOutlines }, scene);\n        cRD.bezel.translate(new BABYLON.Vector3(0, 7.5, 0), 1, BABYLON.Space.LOCAL);\n        //cRD.bezel.rotation = new BABYLON.Vector3(-Math.PI/12, 0, 0);\n        cRD.bezel.material = mats[\"case\"];\n    }\n\n    if (cRD.plateMesh) {\n        scene.removeMesh(cRD.plateMesh);\n    }\n\n    let switchCuts = [];\n    let switchCutsVec = [];\n    for(const [otherId, rd] of Object.entries(kRD)) {\n        for(let cut of rd.switchCut) {\n            let switchOutlineVec = coremath.offsetAndFilletOutline(cut, 0.0, 0.5, false);\n            switchCutsVec.push(switchOutlineVec);\n            switchCuts.push(coremath.genPointsFromVectorPath(switchOutlineVec));\n        }\n        // switchCuts.push(...rd.switchCut);\n    }\n    if( tuning.drawPlate ) {\n        cRD.layers[\"plate\"] = {outlines:[caseFrameVec, ...switchCutsVec]};\n        cRD.plateMesh = BABYLON.MeshBuilder.CreatePolygon(\"plate\", { shape: caseFrame, depth:1.5, holes: switchCuts }, scene);\n        //cRD.plate.translate()\n        cRD.plateMesh.material = mats[\"plate\"];\n    }\n}\n\nexport function refreshKeyboard() {\n    refreshLayout();\n\n    refreshCase();\n}\n\nexport function loadKeyboard(path) {\n    fetch(path)\n        .then(response => response.json())\n        .then(data => {\n            // console.log(data);\n            let mats = globals.renderData.mats;\n\n            let bd = {};\n            bd.meta = data.meta;\n            bd.forceSymmetrical = true;\n            bd.forcePCBSymmetrical = true;\n            bd.caseType = \"convex\";\n            bd.case = data.case;\n            bd.layout = {keys: {}};\n            let kIdx = 0\n            for (let k of data.keys) {\n                k.id = \"key\" + kIdx++;\n                \n                if(!mats[k.color]) {\n                    gfx.createKeyMaterial(k.color,BABYLON.Color3.FromHexString(k.color));\n                }\n                k.matName = k.color;\n                \n                bd.layout.keys[k.id] = k;\n            }\n            globals.boardData = bd;\n            \n            gfx.createMaterials();\n            refreshKeyboard();\n            gfx.snapCamera();\n        });\n}\n","\nimport {globals} from './globals.js'\nimport * as coremath from './coremath.js'\n\nconst formatter = new Intl.NumberFormat('en-US', {\n    minimumFractionDigits: 0,      \n    maximumFractionDigits: 4,\n });\n\n function f(a) { return formatter.format(a)}\n\n\nexport function exportLayerString(layerName) {\n    const bd = globals.boardData;\n    const svg = [];\n    function append(...values) {\n        svg.push.apply(svg, values);\n    }\n    \n    append(`<?xml version=\"1.0\" standalone=\"no\"?>`)\n\n    let bBounds = bd.layout.bounds;\n    let w = bBounds.maxs[0]-bBounds.mins[0]+40\n    let h = -bBounds.mins[1]+bBounds.maxs[1]+40\n\n    //begin svg\n    append(`<svg width=\"${f(w)}mm\" height=\"${f(h)}mm\" viewBox=\"${f(bBounds.mins[0]-20)} ${f(-bBounds.maxs[1]-20)} ${f(w)} ${f(h)}\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">`);\n\n    append(`<title>${bd.meta.name} ${layerName} layer</title>`);\n    \n    append(`<desc>The ${bd.meta.name} ${layerName} layer</desc>`);\n\n    const cRD = globals.renderData.case;\n    let layerData = cRD.layers[layerName];\n    if( layerData.outlines ) {\n        let pathStr = `<path fill=\"red\" fill-rule=\"evenodd\" stroke=\"blue\" stroke-width=\"1\" d=\"`\n        for(let shape of layerData.outlines) {\n            let isL = false;\n            if(shape.length > 1) {\n                // starting point\n                let p = shape[0];\n                switch(p.type) {\n                    case 0:\n                        pathStr += `M${f(p.point.x)},${f(-p.point.z)}`\n                        break;\n                    case 1:\n                        let startPoint = p.center.add(coremath.getNormalFromRot(p.endRot - p.rotDegrees).scale(p.radius));\n                        pathStr += `M${f(startPoint.x)},${f(-startPoint.z)}`\n                        break;\n                }\n\n                for(let i = 0; i <= shape.length; i++) {\n                    let p = shape[i%shape.length];\n                    switch(p.type) {\n                        case 0:\n                            if(!isL) { pathStr+=\"L\"; isL = true; }\n                            pathStr += `${f(p.point.x)},${f(-p.point.z)} `\n                            break;\n                        case 1: // arc\n                            isL = false;\n                            let endPoint = p.center.add(coremath.getNormalFromRot(p.endRot).scale(p.radius));\n                            //(rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n                            pathStr += `A${f(p.radius)},${f(p.radius)} 0 0,0 ${f(endPoint.x)},${f(-endPoint.z)} `\n                            break;\n                    }\n                }\n            }\n        }\n        pathStr += `z\"/>`;\n        append(pathStr);\n    }\n    // append(`<rect x=\"1\" y=\"1\" width=\"398\" height=\"398\" fill=\"none\" stroke=\"blue\" />`);\n    // append(`<path d=\"M 100 100 L 300 100 L 200 300 z\" fill=\"red\" stroke=\"blue\" stroke-width=\"3\" />`);\n\n    //end svg\n    append(`</svg>`);\n\n    return svg.join('\\n');\n}","import {globals} from './globals.js'\nimport {tuning} from './tuning.js'\nimport * as boardOps from './boardOps.js'\nimport * as svg from './svg_export.js'\n\nfunction download(content, fileName, contentType) {\n    var a = document.createElement(\"a\");\n    var file = new Blob([content], {type: contentType});\n    a.href = URL.createObjectURL(file);\n    a.download = fileName;\n    a.click();\n}\n\nfunction downloadSVG(layerName) {\n    const bd = globals.boardData;\n    download(svg.exportLayerString(layerName), `${bd.meta.name}_${layerName}.svg`, 'text/plain');\n}\n\nexport const kbgbGUI = {\n    addButton: function(txt, action, style) {\n        style = style?style:{};\n        var button = BABYLON.GUI.Button.CreateSimpleButton(\"button\", txt);\n        button.top = \"0px\";\n        button.left = \"0px\";\n        button.width = style.width?style.width:\"60px\";\n        button.height = style.height?style.height:\".4\";\n        button.cornerRadius = 5;\n        button.thickness = 2;\n        button.children[0].color = \"#DFF9FB\";\n        button.children[0].fontSize = 24;\n        button.color = \"#FF7979\";\n        button.background = \"#EB4D4B\";\n        //button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    \n        button.onPointerClickObservable.add(action);\n    \n        return button;\n    },\n    addLabel: function(txt) {\n        var t = new BABYLON.GUI.TextBlock();\n        t.width = \"80px\";\n        t.height = \".9\";\n        t.text = txt;\n        t.color = \"white\";\n        t.fontSize = 24;\n        return t;\n    },\n    addKeyActionButton: function(txt, keyAction) {\n        return kbgbGUI.addButton(txt, function () {\n            for (let kId of globals.pickedKeys) {\n                let bd = globals.boardData;\n                let k = bd.layout.keys[kId];\n                keyAction(k);\n            }\n            boardOps.refreshKeyboard();\n        }); \n    },\n    modes:{\n        \"key\":{\n            add: function() {\n                //let ctrlBar = BABYLON.GUI.Control.AddHeader(control, text, size, options { isHorizontal, controlFirst }):\n                let ctrlBar = new BABYLON.GUI.StackPanel();  \n                ctrlBar.height = \".2\";\n                ctrlBar.isPointerBlocker = true;\n                ctrlBar.isVertical = false;\n                //ctrlBar.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n                ctrlBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n            \n                ctrlBar.addControl(kbgbGUI.addLabel(\"Pos: \"));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`◄`, (k) => k.x -= 0.25 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`▲`, (k) => k.y -= 0.25 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`▼`, (k) => k.y += 0.25 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`►`, (k) => k.x += 0.25 ));\n            \n            \n                ctrlBar.addControl(kbgbGUI.addLabel(\"Rot: \"));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⤹`, (k) => k.rotation_angle -= 5 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⤸`, (k) => k.rotation_angle += 5 ));\n            \n                ctrlBar.addControl(kbgbGUI.addLabel(\"W: \"));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⬌`, (k) => k.width += 0.25 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⬄`, (k) => k.width -= 0.25 ));\n            \n                ctrlBar.addControl(kbgbGUI.addLabel(\"H: \"));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⬍`, (k) => k.height += 0.25 ));\n                ctrlBar.addControl(kbgbGUI.addKeyActionButton(`⇳`, (k) => k.height -= 0.25 ));\n                \n                globals.screengui.addControl(ctrlBar);\n                kbgbGUI.activeModeCtrl = ctrlBar;\n            }\n        },\n        \"case\":{\n            add: function() {\n                //let ctrlBar = BABYLON.GUI.Control.AddHeader(control, text, size, options { isHorizontal, controlFirst }):\n                let ctrlBar = new BABYLON.GUI.StackPanel();  \n                ctrlBar.height = \".2\";\n                ctrlBar.isPointerBlocker = true;\n                ctrlBar.isVertical = false;\n                ctrlBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n            \n                ctrlBar.addControl(kbgbGUI.addLabel(\"Type: \"));\n\n                var addRadio = function(text, parent) {\n\n                    var button = new BABYLON.GUI.RadioButton();\n                    button.width = \"20px\";\n                    button.height = \"20px\";\n                    button.color = \"white\";\n                    button.background = \"green\";     \n            \n                    button.onIsCheckedChangedObservable.add(function(state) {\n                        if(state) {\n                            globals.boardData.caseType = text;\n                            boardOps.refreshCase()\n                        }\n                    }); \n            \n                    var header = BABYLON.GUI.Control.AddHeader(button, text, \"100px\", { isHorizontal: true, controlFirst: true });\n                    header.height = \"30px\";\n            \n                    parent.addControl(header);    \n                }\n            \n            \n                let radioCtrl = new BABYLON.GUI.StackPanel();  \n                radioCtrl.height = \"1\";\n                radioCtrl.width = \"200px\";\n                radioCtrl.isVertical = true;\n                addRadio(\"rectangle\", radioCtrl);\n                addRadio(\"convex\", radioCtrl);\n                addRadio(\"concave\", radioCtrl);\n                ctrlBar.addControl(radioCtrl);\n\n                var checkbox = new BABYLON.GUI.Checkbox();\n                checkbox.width = \"20px\";\n                checkbox.height = \"20px\";\n                checkbox.isChecked = globals.boardData.forceSymmetrical;\n                checkbox.color = \"green\";\n                checkbox.onIsCheckedChangedObservable.add(function(value) {\n                    globals.boardData.forceSymmetrical = value;\n                    boardOps.refreshCase();\n                });\n\n                ctrlBar.addControl(kbgbGUI.addLabel(\"SYM: \"));\n                ctrlBar.addControl(checkbox);\n\n                let label = kbgbGUI.addLabel(\"bezel thickness: \")\n                var slider = new BABYLON.GUI.Slider();\n                slider.minimum = 5;\n                slider.maximum = 50;\n                slider.value = tuning.bezelThickness;\n                slider.height = \"20px\";\n                slider.width = \"200px\";\n                slider.onValueChangedObservable.add(function(value) {\n                    label.text = \"Bezel Thickness: \" + (value) + \" mm\";\n                    tuning.bezelThickness = value;\n                    boardOps.refreshCase();\n                });\n                ctrlBar.addControl(label);   \n                ctrlBar.addControl(slider);   \n\n                let filletLabel = kbgbGUI.addLabel(\"bezel fillet: \")\n                var filletSlider = new BABYLON.GUI.Slider();\n                filletSlider.minimum = 0.5;\n                filletSlider.maximum = 20;\n                filletSlider.value = tuning.caseCornerFillet;\n                filletSlider.height = \"20px\";\n                filletSlider.width = \"200px\";\n                filletSlider.onValueChangedObservable.add(function(value) {\n                    filletLabel.text = \"Bezel fillet: \" + (value) + \" mm\";\n                    tuning.caseCornerFillet = value;\n                    boardOps.refreshCase();\n                });\n                ctrlBar.addControl(filletLabel);   \n                ctrlBar.addControl(filletSlider);   \n                \n                globals.screengui.addControl(ctrlBar);\n                kbgbGUI.activeModeCtrl = ctrlBar;\n            }\n        },\n        \"pcb\":{\n            add: function() {\n                //let ctrlBar = BABYLON.GUI.Control.AddHeader(control, text, size, options { isHorizontal, controlFirst }):\n                let ctrlBar = new BABYLON.GUI.StackPanel();  \n                ctrlBar.height = \".2\";\n                ctrlBar.isPointerBlocker = true;\n                ctrlBar.isVertical = false;\n                ctrlBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n            \n                var checkbox = new BABYLON.GUI.Checkbox();\n                checkbox.width = \"20px\";\n                checkbox.height = \"20px\";\n                checkbox.isChecked = globals.boardData.forcePCBSymmetrical;\n                checkbox.color = \"green\";\n                checkbox.onIsCheckedChangedObservable.add(function(value) {\n                    globals.boardData.forcePCBSymmetrical = value;\n                    boardOps.refreshLayout();\n                });\n\n                ctrlBar.addControl(kbgbGUI.addLabel(\"SYM: \"));\n                ctrlBar.addControl(checkbox);\n\n                globals.screengui.addControl(ctrlBar);\n                kbgbGUI.activeModeCtrl = ctrlBar;\n            }\n        },\n        \"details\":{\n            add: function() {\n                //let ctrlBar = BABYLON.GUI.Control.AddHeader(control, text, size, options { isHorizontal, controlFirst }):\n                let ctrlBar = new BABYLON.GUI.StackPanel();  \n                ctrlBar.height = \".2\";\n                ctrlBar.isPointerBlocker = true;\n                ctrlBar.isVertical = false;\n                //ctrlBar.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n                ctrlBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n            \n                let addSVGButton = function(layerName) {\n                    ctrlBar.addControl(kbgbGUI.addButton(layerName, () => {\n                        downloadSVG(layerName);\n                    }, {height:\"60px\",width:\"120px\"}));\n                }\n                addSVGButton(\"bezel\");\n                addSVGButton(\"plate\");\n                addSVGButton(\"edge\");\n                addSVGButton(\"bottom\");\n                addSVGButton(\"pcb\");\n\n                let txt = kbgbGUI.addLabel(\"WORK IN PROGRESS.\");\n\n                txt.width = \"260px\";\n                ctrlBar.addControl(txt);\n                \n\n                globals.screengui.addControl(ctrlBar);\n                \n\n                kbgbGUI.activeModeCtrl = ctrlBar;\n            }\n        },\n    },\n    setGUIMode: function(mode) {\n        if(kbgbGUI.activeModeCtrl) {\n            globals.screengui.removeControl(kbgbGUI.activeModeCtrl);\n        }\n        if(kbgbGUI.modes[mode]) {\n            kbgbGUI.modes[mode].add();\n        }\n    },\n    addModeGUI: function() {\n        let ctrlBar = new BABYLON.GUI.StackPanel();  \n        ctrlBar.height = \".1\";\n        ctrlBar.isPointerBlocker = true;\n        ctrlBar.isVertical = false;\n        //ctrlBar.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n        ctrlBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n        ctrlBar.addControl(kbgbGUI.addButton(\"layout\", () => {kbgbGUI.setGUIMode(\"key\")}, {height:\"1\",width:\"120px\"}));\n        ctrlBar.addControl(kbgbGUI.addButton(\"case\", () => {kbgbGUI.setGUIMode(\"case\")}, {height:\"1\",width:\"120px\"}));\n        ctrlBar.addControl(kbgbGUI.addButton(\"pcb\", () => {kbgbGUI.setGUIMode(\"pcb\")}, {height:\"1\",width:\"120px\"}));\n        ctrlBar.addControl(kbgbGUI.addButton(\"deets\", () => {kbgbGUI.setGUIMode(\"details\")}, {height:\"1\",width:\"120px\"}));\n\n        kbgbGUI.modeCtrl = ctrlBar;\n        globals.screengui.addControl(ctrlBar);\n    }\n}","import {globals} from './globals.js'\nimport {tuning} from './tuning.js'\nimport {kbgbGUI} from './ui.js'\nimport * as boardOps from './boardOps.js'\nimport * as gfx from './gfx.js'\nimport * as dxf from './dxf_export.js'\n\nfunction initKBGB() {\n    gfx.init();\n\n    globals.screengui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"screenUI\");\n\n    kbgbGUI.addModeGUI();\n\n    // run the render loop\n    globals.engine.runRenderLoop(function () {\n        globals.scene.render();\n    });\n\n    let keyboards = [\n        'testkbs/hy_nova.kle',\n        'testkbs/ansi104.kle',\n        'testkbs/fc660m.kle',\n        'testkbs/kle_atreus.kle',\n        'testkbs/basis-mono.kle',\n        'testkbs/basis-stagger-3.kle',\n        'testkbs/kle-ergodox.kle',\n        'testkbs/foggy_sp_knobs.kle',\n        'testkbs/reddit-9d-ortho.kle',\n        'testkbs/onekey.kle',\n        'testkbs/twokey.kle',\n        'testkbs/threekey.kle',\n        'testkbs/threekeyoffset.kle',\n        'testkbs/keysize_test.kle'\n    ]\n    let kbdidx = 13;\n\n    // load a keyboard\n    boardOps.loadKeyboard(keyboards[kbdidx]);\n\n    // the canvas/window resize event handler\n    window.addEventListener('resize', function () {\n        globals.engine.resize();\n    });\n\n    window.addEventListener('keydown', event => {\n        if( event.key == 'i' ) {\n            if(globals.scene.debugLayer.isVisible()) {\n                globals.scene.debugLayer.hide();\n            } else {\n                globals.scene.debugLayer.show();\n            }\n        }\n        if( event.key == 'k' ) {\n            tuning.keyShape = tuning.keyShape?null:\"square\";\n            boardOps.refreshKeyboard();\n        }\n        if( event.key == 'c' ) {\n            tuning.drawCase = tuning.drawCase?false:true;\n            boardOps.refreshKeyboard();\n        }\n        if( event.key == 'p' ) {\n            tuning.drawPlate = tuning.drawPlate?false:true;\n            boardOps.refreshKeyboard();\n        }\n        if( event.key == 'e' ) {\n            tuning.drawPCB = tuning.drawPCB?false:true;\n            boardOps.refreshKeyboard();\n        }\n        if( event.key == 'b' ) {\n            tuning.drawBezel = tuning.drawBezel?false:true;\n            boardOps.refreshKeyboard();\n        }\n        if( event.key == 'r' ) {\n            kbdidx = (kbdidx+1)%keyboards.length;\n            boardOps.loadKeyboard(keyboards[kbdidx]);\n        }\n    })\n}\n\nwindow.addEventListener('DOMContentLoaded', function () {\n    initKBGB();\n});\n\n\n\n//When click event is raised\nwindow.addEventListener(\"click\", function (e) {\n    const scene = globals.scene;\n    var pickResult = scene.pick(scene.pointerX, scene.pointerY);\n    //console.log(pickResult);\n    if (pickResult && pickResult.pickedMesh) {\n        if (globals.boardData.layout.keys[pickResult.pickedMesh.name]) {\n            let pickedKeys = globals.pickedKeys;\n            if (e.metaKey || e.ctrlKey) {\n                if (globals.pickedKeys.indexOf(pickResult.pickedMesh.name) > 0) {\n                    globals.pickedKeys.splice(globals.pickedKeys.indexOf(pickResult.pickedMesh.name), 1)\n                }\n                else {\n                    globals.pickedKeys.push(pickResult.pickedMesh.name)\n                }\n            }\n            else {\n                globals.pickedKeys = [pickResult.pickedMesh.name];\n            }\n            console.log(\"picked key \" + pickResult.pickedMesh.name)\n            boardOps.refreshOutlines();\n        }\n    }\n});"],"names":["globals","pickedKeys","renderData","keys","case","mats","outlines","boardData","tuning","keyDims","switchCutout","base1U","bezelGap","bezelThickness","caseCornerFillet","bezelCornerFillet","keyShape","drawCase","drawBezel","drawPlate","drawPCB","lineLineIntersection","p0","d0","p1","d1","det","x","z","Math","abs","BABYLON","Epsilon","prevC","nextC","Vector3","segmentToSegment","x0","x1","xL","xNorm","y0","y1","yL","subtract","result","intersection","normalize","type","y0Dot","Dot","y1Dot","x0Dot","x1Dot","dir","xNormalized","normalizeToNew","dot","nearestPoint","add","scale","lengthSquared","pointToLineDistSq","isPointInPoly","p","poly","i","length","point","nextDir","nextNorm","pV","getRotFromNormal","norm","t","acos","PI","getNormalFromRot","rot","cos","sin","orient","a","b","c","s","l","r","tol","convexHull2d","points","n","Array","sorted","sort","d","lower","upper","idx","m","pop","push","ptr","nl","j","pList","unshift","Point","this","Arc","center","radius","rotDegrees","endRot","offsetAndFilletOutline","outline","offset","fillets","close","vectorOutline","next","prev","prevDir","prevNorm","inPoint","outPoint","fillet","flip","filletCenter","startRot","totRot","genPointsFromVectorPath","vectorPath","segmentsPerFillet","outPoints","nextItem","rotStep","genArrayFromOutline","segments","createKeyMaterial","name","color","PBRMetallicRoughnessMaterial","scene","metallic","roughness","baseColor","environmentTexture","hdrTexture","init","canvas","document","getElementById","engine","Engine","Scene","camera","ArcRotateCamera","setTarget","Zero","fov","lowerRadiusLimit","upperRadiusLimit","attachControl","ssao","SSAORenderingPipeline","base","area","falloff","CubeTexture","CreateFromPrefilteredData","currentSkybox","createDefaultSkybox","activeCamera","maxZ","minZ","createScene","refreshOutlines","kRD","oRD","k","o","Object","entries","removeMesh","id","rd","MeshBuilder","CreateRibbon","pathArray","coremath.genArrayFromOutline","material","translate","Space","LOCAL","console","log","getPlateCutsWithStabs","width","height","kXform","plateCuts","pcbBounds","switchCutDims","sXform","Matrix","Translation","multiply","TransformCoordinates","keyPCBBounds","span","RotationY","stabCutDims","stabOffsetXL","stabOffsetXR","stabXforms","stabCut","stabPCBFootDims","stabFoot","xformedCut","xformedPCBBounds","refreshLayout","bd","mins","maxs","bezelHoles","keycap","kgID","layout","keyGroupId","bezelMins","bezelMaxs","overlappingKeys","keycapDim","kPos","y","Identity","rotation_angle","rotation_x","rotation_y","pcbBoxes","switchCut","CreatePolygon","shape","depth","updatable","matName","bezelHole","min","max","checkOverlap","k1","rd1","k2","rd2","checkIntersection","pRD","iP","line","allLess","allMore","oP","confirmedIntersection","pKG","oKG","otherId","otherRD","bounds","kPs","pcbOutline","coremath.convexHull2d","forcePCBSymmetrical","midPoint","getCombinedOutlineFromRDGroup","KG","outlineLines","parsedOutlineLines","lStart","lEnd","maxOverlapSq","overlapFunc","primeL","primeLen","otherLen","distBetween","lineArray","parseArray","primeToOtherNear","primeToOtherFar","splice","visitedForOutline","oId","iL","lL","lDir","lLen","lineNorm","normalizeFromLength","jL","oL","oDir","oLen","oLNorm","lineDot","diff","d2ls","dd","overlapDist","lNorm","intersections","colinear","iOP","segRes","coremath.segmentToSegment","isStartInPoly","coremath.isPointInPoly","isEndInPoly","tmp","nextKeyRd","nextLineIndex","invertNextLine","prevLine","nextDistSq","checkNext","nRd","newDistSq","refreshCase","caseType","forceSymmetrical","cRD","layers","cavityInnerEdgeVec","coremath.offsetAndFilletOutline","caseFrameVec","caseFrame","coremath.genPointsFromVectorPath","edgeMesh","holes","map","bottom","pcbMesh","pcbOutlineVec","keyGroups","bezelOutlineVecs","bezelOutlines","kgId","bezelOutlineVec","bezel","plateMesh","switchCuts","switchCutsVec","cut","switchOutlineVec","refreshKeyboard","loadKeyboard","path","fetch","then","response","json","data","meta","kIdx","gfx.createKeyMaterial","Color3","FromHexString","StandardMaterial","diffuseColor","emissiveColor","specularColor","caseMatName","plateMatName","pcbMatName","gfx.createMaterials","alpha","beta","gfx.snapCamera","formatter","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","f","format","downloadSVG","layerName","content","fileName","contentType","file","svg","append","values","apply","bBounds","w","h","layerData","pathStr","isL","startPoint","coremath.getNormalFromRot","endPoint","join","svg.exportLayerString","createElement","Blob","href","URL","createObjectURL","download","click","kbgbGUI","addButton","txt","action","style","button","GUI","Button","CreateSimpleButton","top","left","cornerRadius","thickness","children","fontSize","background","onPointerClickObservable","addLabel","TextBlock","text","addKeyActionButton","keyAction","kId","boardOps.refreshKeyboard","modes","key","ctrlBar","StackPanel","isPointerBlocker","isVertical","verticalAlignment","Control","VERTICAL_ALIGNMENT_BOTTOM","addControl","screengui","activeModeCtrl","addRadio","parent","RadioButton","onIsCheckedChangedObservable","state","boardOps.refreshCase","header","AddHeader","isHorizontal","controlFirst","radioCtrl","checkbox","Checkbox","isChecked","value","label","slider","Slider","minimum","maximum","onValueChangedObservable","filletLabel","filletSlider","pcb","boardOps.refreshLayout","details","addSVGButton","setGUIMode","mode","removeControl","addModeGUI","VERTICAL_ALIGNMENT_TOP","modeCtrl","window","addEventListener","gfx.init","AdvancedDynamicTexture","CreateFullscreenUI","runRenderLoop","render","keyboards","kbdidx","boardOps.loadKeyboard","resize","event","debugLayer","isVisible","hide","show","initKBGB","e","pickResult","pick","pointerX","pointerY","pickedMesh","metaKey","ctrlKey","indexOf","boardOps.refreshOutlines"],"mappings":"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"}